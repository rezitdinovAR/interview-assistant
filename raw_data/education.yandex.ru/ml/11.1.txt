---
title: Обучение с подкреплением
url: https://education.yandex.ru/handbook/ml/article/obuchenie-s-podkrepleniem
course: ml
chapter: 11. Взаимодействие со средой
chapter_id: 11.1
---
До сих пор опыт, благодаря которому было возможно обучение в наших алгоритмах, был задан в виде обучающей выборки. Насколько такая модель обучения соотносится с тем, как учится, например, человек? Чтобы научиться кататься на велосипеде, печь тортики или играть в теннис, нам не нужны огромные датасеты с примерами того, что нужно делать в каждый момент; вместо этого мы способны обучаться методом проб и ошибок (trial and error), предпринимая попытки решить задачу, взаимодействуя с окружающим миром, и как-то улучшая своё поведение на основе полученного в ходе этого взаимодействия опыта.
В обучении с подкреплением (reinforcement learning, RL) мы хотим построить алгоритм, моделирующий обучение методом проб и ошибок. Вместо получения обучающей выборки на вход такой алгоритм будет взаимодействовать с некоторой средой (environment), окружающим миром, а в роли «разметки» будет выступать награда (reward) — скалярная величина, которая выдаётся после каждого шага взаимодействия со средой и показывает, насколько хорошо алгоритм справляется с поставленной ему задачей. Например, если вы печёте тортики, то за каждый испечённый тортик вы получаете +1, а если вы пытаетесь кататься на велосипеде, то за каждое падение с велосипеда вам прилетает -1.
Награда не подсказывает, как именно нужно решать задачу и что вообще нужно делать;
Награда может быть отложенной во времени (вы нашли в пустыне сокровища, но чтобы получить заслуженные тортики, вам ещё понадобится куча времени, чтобы выбраться из пустыни; а награда приходит только за тортики) или сильно разреженной (большую часть времени давать агенту +0). Всё это сильно отличает задачу от обучения с учителем;
Награда предоставляет какой-то «сигнал» для обучения (хорошо/плохо), которого нет, например, в обучении без учителя.
источник картинки — курс UC Berkeley AI
Постановка задачи
Теперь попробуем формализовать всю эту концепцию и познакомиться с местной терминологией. Задача обучения с подкреплением задаётся Марковским Процессом Принятия Решений (Markov Decision Process или сокращённо MDP) это четвёрка
(S,A,P,r), где:
S
S — пространство состояний (state space), множество состояний, в которых в каждый момент времени может находиться среда.
A
A — пространство действий (action space), множество вариантов, из которых нужно производить выбор на каждом шаге своего взаимодействия со средой.
P
P — функция переходов (transition function), которая задаёт изменение среды после того, как в состоянии
s
∈
S
s∈S было выбрано действие
a
∈
A
a∈A. В общем случае функция переходов может быть стохастична, и тогда такая функция переходов моделируется распределением
p(s
′
∣s,a): с какой вероятностью в какое состояние перейдёт среда после выбора действия
a
a в состоянии
r:S×A→R — функция награды (reward function), выдающая скалярную величину за выбор действия
a
a в состоянии
s
s. Это наш «обучающий сигнал».
Традиционно субъект, взаимодействующий со средой и влияющий на неё, называется в обучении с подкреплением агентом (agent). Агент руководствуется некоторым правилом, возможно, тоже стохастичным, как выбирать действия в зависимости от текущего состояния среды, которое называется стратегией (policy; термин часто транслитерируют и говорят политика) и моделируется распределением
π(a∣s). Стратегия и будет нашим объектом поиска, поэтому, как и в классическом машинном обучении, мы ищем какую-то функцию.
Взаимодействие со средой агента со стратегией
π(a∣s) моделируется так. Изначально среда находится в некотором состоянии
s
0
s
0
. Агент сэмплирует действие из своей стратегии
∼π(a
0
∣s
0
). Среда отвечает на это, сэмплируя своё следующее состояние
∼p(s
1
∣s
0
,a
0
) из функции переходов, а также выдаёт агенту награду в размере
r(s
0
,a
0
). Процесс повторяется: агент снова сэмплирует
a
1
a
1
, а среда отвечает генерацией
s
2
s
2
и скалярной наградой
r(s
1
,a
1
). Так продолжается до бесконечности или пока среда не перейдёт в терминальное состояние, после попадания в которое взаимодействие прерывается, и сбор агентом награды заканчивается. Если в среде есть терминальные состояния, одна итерация взаимодействия от начального состояния до попадания в терминальное состояние называется эпизодом (episode). Цепочка генерируемых в ходе взаимодействия случайных величин
,… называется траекторией (trajectory). Примечание: функция награды тоже может быть стохастичной, и тогда награды за шаг тоже будут случайными величинами и частью траекторий, но без ограничения общности мы будем рассматривать детерминированные функции награды.
MDP
Итак, фактически среда для нас — это управляемая марковская цепь: на каждом шаге мы выбором
a
a определяем то распределение, из которого будет генерироваться следующее состояние. Мы предполагаем, во-первых, марковское свойство: что переход в следующее состояние определяется лишь текущим состоянием и не зависит от всей предыдущей истории:
p(s
t+1
∣s
t
,a
t
,s
t−1
,a
t−1
,…,s
0
,a
0
)=p(s
t+1
∣s
t
,a
t
)
Во-вторых, мы предполагаем стационарность: функция переходов
p(s
′
∣s,a) не зависит от времени, от того, сколько шагов прошло с начала взаимодействия. Это довольно реалистичные предположения: законы мира не изменяются со временем (стационарность), а состояние — описывает мир целиком (марковость). В этой модели взаимодействия есть только одно нереалистичное допущение: полная наблюдаемость (full observability), которая гласит, что агент в своей стратегии
π(a∣s) наблюдает всё состояние
s
s полностью и может выбирать действия, зная об окружающем мире абсолютно всё; в реальности нам же доступны лишь какие-то частичные наблюдения состояния. Такая более реалистичная ситуация моделируется в частично наблюдаемых MDP (Partially observable MDP, PoMDP), но мы далее ограничимся полностью наблюдаемыми средами.
Итак, мы научились на математическом языке моделировать среду, агента и их взаимодействие между собой. Осталось понять, чего же мы хотим. Во время взаимодействия на каждом шаге агенту приходит награда
=r(s
t
,a
t
), однако, состояния и действия
в рамках такой постановки — случайные величины. Один и тот же агент может в силу стохастики как внутренней (в силу случайности выбора действий в его стратегии), так и внешней (в силу стохастики в функции переходов) набирать очень разную суммарную награду
t≥0
r
t
в зависимости от везения. Мы скажем, что хотим научиться выбирать действия так, чтобы собирать в среднем как можно больше награды.
Что значит в среднем, в среднем по чему? По всей стохастике, которая заложена в нашем процессе взаимодействия со средой. Каждая стратегия
π
π задаёт распределение в пространстве траекторий — с какой вероятностью нам может встретится траектория
T=(s
,…):
p(T∣π)=p(s
,⋯∣π)=
t≥0
∏
p(s
t+1
∣s
t
,a
t
)π(a
t
∣s
t
)
Вот по такому распределению мы и хотим взять среднее получаемой агентом награды. Записывают это обычно как-нибудь так:
max
⁡
π
E
T∼π
t≥0
∑
r
t
→
π
max
Здесь мат.ожидание по траекториям — это бесконечная цепочка вложенных мат.ожиданий:
T∼π
(⋅)=E
a
0
∼π(a
∼p(s
∼π(a
1
∣s
1
)
…(⋅)
Вот такую конструкцию мы и хотим оптимизировать выбором стратегии
π
π. На практике, однако, вносят ещё одну маленькую корректировку. В средах, где взаимодействие может продолжаться бесконечно долго, агент может научиться набирать бесконечную награду, с чем могут быть связаны разные парадоксы (например, получать +1 на каждом втором шаге становится также хорошо, как получать +1 на каждом сотом шаге). Поэтому вводят дисконтирование (discounting) награды, которое гласит: тортик сейчас лучше, чем тот же самый тортик завтра. Награду, которую мы получим в будущем, агент будет дисконтировать на некоторое число
γ
γ, меньшее единицы. Тогда наш функционал примет такой вид:
max
⁡
π
E
T∼π
t≥0
max
источник картинки — курс UC Berkeley AI
Заметим, что обучение с подкреплением - это в первую очередь задача оптимизации, оптимизации функционалов определённого вида. Если в классическом машинном обучении подбор функции потерь можно считать элементом инженерной части решения, то здесь функция награды задана нам готовая и определяет тот функционал, который мы хотим оптимизировать.
Окей, и как такое решать?
Выглядит сложновато, но у человечества есть уже довольно много наработок, как подойти к этой на вид очень общей задаче, причём с основной идеей вы скорее всего уже сталкивались. Называется она динамическим программированием.
Дело в том, что мы оптимизируем не абы какой функционал, а среднюю дисконтированную кумулятивную награду. Чтобы придумать более эффективное решение, чем какой-нибудь подход, не использующий этот факт (например, эволюционные алгоритмы), нам нужно воспользоваться структурой поставленной задачи. Эта структура задана в формализме MDP и определении процесса взаимодействия агента со средой. Интуитивно она выражается так: вот мы сидим в некотором состоянии
s
s и хотим выбрать действие
a
a как можно оптимальнее. Мы знаем, что после выбора этого действия мы получим награду за этот шаг
r=r(s,a), среда перекинет нас в состояние
s
′
s
′
и, внимание, дальше нас ждёт подзадача эквивалентной структуры: в точности та же задача выбора оптимального действия, только в другом состоянии. Действительно: когда мы будем принимать решение на следующем шаге, на прошлое мы повлиять уже не способны; стационарность означает, что законы, по которым ведёт себя среда, не поменялись, а марковость говорит, что история не влияет на дальнейший процесс нашего взаимодействия. Это наводит на мысль, что задача максимизации награды из текущего состояния тесно связана с задачей максимизации награды из следующего состояния
s
′
s
′
, каким бы оно ни было.
Чтобы сформулировать это на языке математики, вводятся «дополнительные переменные», вспомогательные величины, называемые оценочными функциями. Познакомимся с одной такой оценочной функцией - оптимальной Q-функцией, которую будем обозначать
(s,a). Скажем, что
(s,a) - это то, сколько максимально награды можно (в среднем) набрать после выбора действия
a
a из состояния
s
s. Итак:
max
(s,a)=
π
max
E
T∼π∣s
0
=s,a
0
=a
t≥0
∑
γ
t
r
t
Запись
T∼π∣s
0
=s,a
0
=a здесь означает, что мы садимся в состояние
=s; выбираем действие
=a, а затем продолжаем взаимодействие со средой при помощи стратегии
π
π, порождая таким образом траекторию
T
T. По определению, чтобы посчитать
(s,a), нужно перебрать все стратегии, посмотреть, сколько каждая из них набирает награды после выбора
a
a из состояния
s
s, и взять наилучшую стратегию. Поэтому эта оценочная функция называется оптимальной: она предполагает, что в будущем после выбора действия
a
a из состояния
s
s агент будет вести себя оптимально.
Определение неконструктивное, конечно, поскольку в реальности мы так сделать не можем, зато обладает интересным свойством. Если мы каким-то чудом узнали
(s,a), то мы знаем оптимальную стратегию. Действительно: представьте, что вы находитесь в состоянии
s
s, вам нужно сделать выбор из трёх действий, и вы знаете значения
(s,a). Вы знаете, что если выберете первое действие
a
=
0
a=0, то в будущем сможете набрать не более чем, допустим,
(s,a=0)=+3 награды. При этом вы знаете, что существует какая-то стратегия
π
π, на которой достигается максимум в определении оптимальной Q-функции, то есть которая действительно позволяет набрать эти +3. Вы знаете, что если выберете второе действие, то в будущем сможете набрать, допустим,
(s,a=1)=+10, а для третьего действия
(s,a=2)=−1. Вопрос: так как нужно действовать? Интуиция подсказывает, что надо просто выбирать действие
a
=
1
a=1, что позволит набрать +10, ведь по определению больше набрать никак не получится. Значит, выбор в этом состоянии действия
a
=
1
a=1 оптимален. Эта интуиция нас не обманывает, и принцип такого выбора называется принципом оптимальности Беллмана.
Выбор того действия, на котором достигается максимум по действиям Q-функции, называется жадным (greedy) по отношению к ней. Таким образом, принцип оптимальности Беллмана гласит:
жадный выбор по отношению к оптимальной Q-функции оптимален:
argmax
(s)=argmax
a
Q
∗
(s,a)
Примечание: если Q-функция достигает максимума на нескольких действиях, то можно выбирать любое из них.
Заметим, что эта оптимальная стратегия детерминирована. Этот интересный факт означает, что нам, в общем-то, необязательно искать стохастичную стратегию. Наше рассуждение пока даже показывает, что мы можем просто пытаться найти
(s,a), а дальше выводить из неё оптимальную стратегию, выбирая действие жадно.
Но как искать
(s,a)? Тут на сцене и появляется наше наблюдение про структуру задачи. Оказывается,
(s,a) выражается через саму себя. Действительно: рассмотрим некоторую пару состояние-действие
s
,
a
s,a. С одной стороны, по определению, мы в будущем сможем при условии оптимального поведения получить
(s,a) награды. С другой стороны, после того, как мы выберем действие
a
a в состоянии
s
s, мы получим награду за один шаг
r(s,a), вся дальнейшая награда будет дисконтирована на
γ
γ, среда ответит нам сэмплированием
∼p(s
′
∣s,a) (на результат этого сэмплирования мы уже никак повлиять не можем и по этой стохастике нашу будущую награду надо будет усреднять), а затем в состоянии
s
′
s
′
мы, в предположении оптимальности поведения, выберем то действие
a
′
a
′
, на котором достигается максимум
). Другими словами, в дальнейшем после попадания в
s
′
s
′
мы сможем получить
max
max
) награды. А значит, верно следующее рекурсивное соотношение, называемое уравнением оптимальности Беллмана для Q-функции:
max
(s,a)=r(s,a)+γE
s
′
∼p(s
′
∣s,a)
a
′
max
Мы получили систему уравнений, связывающую значения
(s,a) с самой собой. Это нелинейная система уравнений, но оказывается, что она в некотором смысле «хорошая». У неё единственное решение - и, значит, решение этого уравнения можно считать эквивалентным определением
(s,a), - и его можно искать методом простой итерации. Метод простой итерации решения систем уравнений позволяет улучшать своё текущее приближение
x
x решения некоторого уравнения вида
x=f(x) его подстановкой в правую часть. То есть: инициализируем произвольную функцию
(s,a):S×A→R, которая будет приближать
(s,a), затем итеративно будем подставлять её в правую часть уравнений оптимальности Беллмана и полученным значением обновлять наше приближение:
max
k+1
∗
(s,a)←r(s,a)+γE
s
′
∼p(s
′
∣s,a)
a
′
max
Такая процедура в пределе приведёт нас к истинной
(s,a), а значит и оптимальной стратегии. Кстати, когда вы в прошлом встречались с динамическим программированием, вы скорее всего неявно использовали именно эту идею, разве что часто в задачах для решения уравнений оптимальности Беллмана можно просто последовательно исключать неизвестные переменные; но метод простой итерации даёт более общую схему, применимую всегда. А сейчас для нас принципиально следующее: если у нас есть какое-то приближение
Q
∗
Q
∗
, то вычисление правой части уравнения оптимальности Беллмана позволит получить приближение лучше.
А где же метод проб и ошибок?
Решать методом простой итерации уравнения оптимальности Беллмана и таким образом получать
(s,a) в реальности можно только при двух очень существенных ограничивающих условиях. Нужно, чтобы, во-первых, мы могли хранить как-то текущее приближение
(s,a) в памяти. Это возможно только если пространства состояний и действий конечные и не очень большие, то есть, например, в вашем MDP всего 10 состояний и 5 действий, тогда
(s,a) — это табличка 10x5. Но что, если вы хотите научиться играть в видеоигру, и состояние — это входное изображение? Тогда множество картинок, которые вам может показать видеоигра, сохранить в памяти уже не получится. Ну, допустим пока, что число состояний и число действий не очень большое, и мы всё-таки можем хранить таблицу в памяти, а позже мы снимем это ограничение, моделируя
(s,a) при помощи нейросети.
Во-вторых, нам необходимо уметь считать выражение, стоящее справа в уравнение оптимальности Беллмана:
max
r(s,a)+γE
s
′
∼p(s
′
∣s,a)
a
′
max
Мало того, что в сложных средах взять мат.ожидание по функции переходов
∼p(s
′
∣s,a)
в реальности мы не сможем, так ещё и обычно мы эту функцию переходов на самом деле не знаем. Представьте, что вы катаетесь на велосипеде: можете ли вы по текущему состоянию окружающего мира, например, положению всех атомов во вселенной, рассказать, с какими вероятностями в каком состоянии мир окажется в следующий момент времени? Это соображение также подсказывает, что было бы здорово, если б мы смогли решать задачу, избегая даже попыток выучить эту сложную функцию переходов.
Что нам доступно? Мы можем взять какую-нибудь стратегию
π
π (важный момент: мы должны сами выбрать какую) и повзаимодействовать ею со средой. «Попробовать решить задачу». Мы можем сгенерировать при помощи
π
π целую траекторию или даже сделать всего один шаг в среде. Таким образом мы соберём данные: допустим, мы были в состоянии
s
s и сделали выбор действия
a
a, тогда мы узнаем, какую награду
r=r(s,a) мы получаем за такой шаг и, самое главное, в какое состояние
s
′
s
′
нас перевела среда. Полученный
s
′
s
′
— сэмпл из функции переходов
∼p(s
′
∣s,a). Собранная так информация — четвёрка
(s,a,r,s
′
) — называется переходом (transition), и может быть как-то использована для оптимизации нашей стратегии.
Можем ли мы, используя лишь переходы
(s,a,r,s
′
), то есть имея на руках лишь сэмплы
∼p(s
′
∣s,a), как-то пользоваться схемой динамического программирования? Что, если мы будем заменять значение
(s,a) не на
max
r(s,a)+γE
s
′
∼p(s
′
∣s,a)
a
′
max
которое мы не можем посчитать, а на его Монте Карло оценку:
max
r(s,a)+γ
a
′
max
где
s
′
s
′
— сэмпл из функции переходов из собранного нами опыта? В среднем-то такая замена верная. Такая Монте-Карло оценка правой части для заданного переходика
(s,a,r,s
′
) называется Беллмановским таргетом, то есть «целевой переменной». Почему такое название — мы увидим чуть позже.
Чтобы понять, как нам нужно действовать, рассмотрим какую-нибудь типичную ситуацию. Допустим, после выполнения действия
a
a из некоторого состояния
s
s среда награждает нас
r(s,a)=0 и перекидывает нас с равными вероятностями то в состояние
s
′
s
′
, для которого
max
max
)=+1, то в состояние
s
′
s
′
, для которого
max
max
)=−1. Метод простой итерации говорит, что на очередной итерации нужно заменить
(s,a) на
0.5
0.5
0.5γ⋅(+1)+0.5γ⋅(−1)=0, но в реальности мы встретимся лишь с одним исходом, и таргет — Монте-Карло оценка правой части уравнения оптимальности Беллмана — будет с вероятностью 0.5 равен
+
γ
+γ, а с вероятностью 0.5 равен
−
γ
−γ. Ясно, что нельзя просто взять и жёстко заменять наше текущее приближение
(s,a) на посчитанный Беллмановский таргет по некоторому одному переходу, поскольку нам могло повезти (мы увидели
+
γ
+γ) или не повезти (мы увидели
−
γ
−γ). Давайте вместо этого поступать также, как учат среднее по выборке: не сдвигать «жёстко» наше текущее приближение в значение очередного сэмпла, а смешивать текущее приближение с очередным сэмплом. То есть: берём переходик
(s,a,r,s
′
), и не заменяем
(s,a) на стохастичную оценку правой части уравнения оптимальности Беллмана, а только сдвигаемся в его сторону:
max
k+1
∗
(s,a)←(1−α)Q
k
∗
(s,a)+α(r+γ
a
′
max
Таким образом, мы проводим экспоненциальное сглаживание старого приближения
(s,a) и новой оценки правой части уравнения оптимальности Беллмана со свежим сэмплом
s
′
s
′
. Выбор
α
α здесь определяет, насколько сильно мы обращаем внимание на последние сэмплы, и имеет тот же физический смысл, что и learning rate. В среднем по стохастике (а стохастика в этой формуле обновления заложена в случайном
s
′
s
′
) мы будем сдвигаться в сторону
max
r(s,a)+γE
s
′
∼p(s
′
∣s,a)
a
′
max
и значит применять этакий «зашумлённый» метод простой итерации.
Итак, возникает следующая идея. Будем как-то взаимодействовать со средой и собирать переходики
(s,a,r,s
′
). Для каждого перехода будем обновлять одну ячейку нашей Q-таблицы размера число состояний на число действий по вышеуказанной формуле. Таким образом мы получим как бы «зашумлённый» метод простой итерации, где мы на каждом шаге обновляем только одну ячейку таблицы, и не заменяем жёстко значение на правую часть уравнений оптимальности, а лишь сдвигаемся по некоторому в среднем верному стохастичному направлению.
Очень похоже на стохастическую оптимизацию вроде стохастического градиентного спуска, и поэтому гарантии сходимости выглядят схожим образом. Оказывается, такой алгоритм сходится к истинной
(s,a), если для любой пары
s
,
a
s,a мы в ходе всего процесса проводим бесконечное количество обновлений, а learning rate (гиперпараметр
α
α) в них ведёт себя как learning rate из условий сходимости стохастического градиентного спуска:
=+∞,
i
∑
α
i
2
<+∞
Этот алгоритм, к которому мы уже практически пришли, называется Q-learning, «обучение оптимальной Q-функции». Нам, однако, осталось ответить на один вопрос: так как же нужно собирать данные, чтобы удовлетворить требованиям для сходимости? Как взаимодействовать со средой так, чтобы мы каждую ячейку
s
,
a
s,a не прекращали обновлять?
Дилемма Exploration-exploitation
Мы уже встречали дилемму exploration-exploitation (букв. «исследования-использования») в параграфе про тюнинг гиперпараметров. Задача многоруких бандитов, которая там встретилась, на самом деле является частным случаем задачи обучения с подкреплением, в котором после первого выбора действия эпизод гарантированно завершается, и этот частный случай задачи часто используется для изучения этой дилеммы. Рассмотрим эту дилемму в нашем контексте.
Допустим, на очередном шаге алгоритма у нас есть некоторое приближение
(s,a)≈Q
∗
(s,a). Приближение это, конечно, неточное, поскольку алгоритм, если и сходится к истинной оптимальной Q-функции, то на бесконечности. Как нужно взаимодействовать со средой? Если вы хотите набрать максимальную награду, наверное, стоит воспользоваться нашей теорией и заниматься exploitation-ом, выбирая действие жадно:
π
(
s
)
=
argmax
π(s)=argmax
a
Q
k
(s,a)
Увы, такой выбор не факт что совпадёт с истинной оптимальной стратегией, а главное, он детерминирован. Это значит, что при взаимодействии этой стратегией со средой, многие пары
s
,
a
s,a никогда не будут встречаться просто потому, что мы никогда не выбираем действие
a
a в состоянии
s
s. А тогда мы, получается, рискуем больше никогда не обновить ячейку
(s,a) для таких пар!
Такие ситуации запросто могут привести к застреванию алгоритма. Мы хотели научиться кататься на велосипеде и получали +0.1 за каждый пройденный метр и -5 за каждое попадание в дерево. После первых проб и ошибок мы обнаружили, что катание на велосипеде приносит нам -5, поскольку мы очень скоро врезаемся в деревья и обновляли нашу аппроксимацию Q-функции сэмплами с негативной наградой; зато если мы не будем даже забираться на велосипед и просто займёмся ничего не деланьем, то мы сможем избежать деревьев и будем получать 0. Просто из-за того, что в нашей стратегии взаимодействия со средой никогда не встречались те
s
,
a
s,a, которые приводят к положительной награде, и жадная стратегия по отношению к нашей текущей аппроксимации Q-функции никогда не выбирает их. Поэтому нам нужно экспериментировать и пробовать новые варианты.
Режим exploration-а предполагает, что мы взаимодействуем со средой при помощи какой-нибудь стохастичной стратегии
∀s,a:π(a∣s)>0. Например, такой стратегией является случайная стратегия, выбирающая рандомные действия. Как ни странно, сбор опыта при помощи случайной стратегии позволяет побывать с ненулевой вероятностью во всех областях пространства состояний, и теоретически даже наш алгоритм обучения Q-функции будет сходится. Означает ли это, что exploration-а хватит, и на exploitation можно забить?
В реальности мы понимаем, что добраться до самых интересных областей пространства состояний, где функция награда самая большая, не так-то просто, и случайная стратегия хоть и будет это делать с ненулевой вероятностью, но вероятность эта будет экспоненциально маленькая. А для сходимости нам нужно обновить ячейки
(s,a) для этих интересных состояний бесконечно много раз, то есть нам придётся дожидаться необычайно редкого везения далеко не один раз. Куда разумнее использовать уже имеющиеся знания и при помощи жадной стратегии, которая уже что-то умеет, идти к этим интересным состояниям. Поэтому для решения дилеммы exploration-exploitation обычно берут нашу текущую жадную стратегию и что-нибудь с ней делают такое, чтобы она стала чуть-чуть случайной. Например, с вероятностью
ε
>
0
ε>0 выбирают случайное действие, а с вероятностью
1
−
ε
1−ε — жадное. Тогда мы чаще всё-таки и знаниями пользуемся, и любое действие с ненулевой вероятностью выбираем; такая стратегия называется
ε
ε-жадной, и она является самым простым способом как-то порешать эту дилемму.
Давайте закрепим, что у нас получилось, в виде табличного алгоритма обучения с подкреплением под названием Q-learning:
Проинициализировать
(s,a) произвольным образом.
Пронаблюдать
s
0
s
0
из среды.
Для
k=0,1,2,…:
с вероятностью
ε
ε выбрать действие
a
k
a
k
случайно, иначе жадно:
a
k
=
argmax
​=argmax
​,a
k
​)
отправить действие
a
k
a
k
в среду, получить награду за шаг
r
k
r
k
и следующее состояние
s
k
+
1
s
k+1
.
обновить одну ячейку таблицы:
max
)←(1−α)Q
∗
(s
k
,a
k
)+α(r
k
+γ
a
′
max
Q
∗
(s
k+1
,a
′
))
Добавим нейросеток
Наконец, чтобы перейти к алгоритмам, способным на обучение в сложных MDP со сложным пространством состояний, нужно объединять классическую теорию обучения с подкреплением с парадигмами глубокого обучения.
Допустим, мы не можем позволить себе хранить
(s,a) как таблицу в памяти, например, если мы играем в видеоигру и на вход нам подаются какие-нибудь изображения. Тогда мы можем обрабатывать любые имеющиеся у агента входные сигналы при помощи нейросетки
(s,a,θ). Для тех же видеоигр мы легко обработаем изображение экрана небольшой свёрточной сеточкой и выдадим для каждого возможного действия
a
a вещественный скаляр
(s,a,θ). Допустим также, что пространство действий всё ещё конечное и маленькое, чтобы мы могли для такой модели строить жадную стратегию, выбирать
argmax
argmax
a
Q
∗
(s,a,θ). Но как обучать такую нейросетку?
Давайте ещё раз посмотрим на формулу обновления в Q-learning для одного переходика
(s,a,r,s
max
max
k+1
∗
(s,a)←(1−α)Q
k
∗
(s,a)+α(r+γ
a
′
max
))=
=Q
k
∗
(s,a)+α(r+γ
a
′
max
)−Q
k
∗
(s,a))
Теория Q-learning-а подсказывала, что у процесса такого обучения Q-функции много общего с обычным стохастическим градиентным спуском. В таком виде формула подсказывает, что, видимо,
r
+
γ
max
r+γ
a
′
max
)−Q
k
∗
(s,a)
— это стохастическая оценка какого-то градиента. Этот градиент сравнивает Беллмановский таргет
r
+
γ
max
r+γ
a
′
max
с нашим текущим приближением
(s,a) и чуть-чуть корректирует это значение, сдвигая в сторону таргета. Попробуем «заменить» в этой формуле Q-функцию с табличного представления на нейросетку.
Рассмотрим такую задачу регрессии. Чтобы построить один прецедент для обучающей выборки, возьмём один имеющийся у нас переходик
(s,a,r,s
′
). Входом будет пара
s
,
a
s,a. Целевой переменной, таргетом, будет Беллмановский таргет
y
=
r
+
γ
max
y=r+γ
a
′
max
,θ);
его зависимость от параметров
θ
θ нашей нейронки мы далее будем игнорировать и будем «притворяться», что это и есть наш ground truth. Именно поэтому Монте-Карло оценка правой части уравнения оптимальности Беллмана и называют таргетом. Но важно помнить, что эта целевая переменная на самом деле «зашумлена»: в формуле используется взятый из перехода
s
′
s
′
, который есть лишь сэмпл из функции переходов. На самом же деле мы хотели бы выучить среднее значение такой целевой переменной, и поэтому в качестве функции потерь мы возьмём MSE. Как будет выглядеть шаг стохастического градиентного спуска для решения этой задачи регрессии (для простоты — для одного прецедента)?
max
k+1
←
=
=
θ
k
−α∇
θ
(y−Q
∗
(s,a,θ))
2
=
θ
k
+2α(y−Q
∗
(s,a,θ))∇
θ
Q
∗
(s,a,θ)=
θ
k
+2α(r+γ
a
′
max
,θ)−Q
∗
(s,a,θ))∇
θ
Q
∗
(s,a,θ)
Это практически в точности повторяет формулу Q-learning, которая гласит, что если таргет
r
+
γ
max
r+γmax
,θ) больше
(s,a,θ), то нужно подстроить веса нашей модели так, чтобы
(s,a,θ) стало чуть побольше, и наоборот. В среднем при такой оптимизации мы будем двигаться в сторону
max
∼p(s
′
∣s,a)
y=E
s
′
∼p(s
′
∣s,a)
[r+γ
a
′
max
,θ)]
— в сторону правой части уравнения оптимальности Беллмана, то есть моделировать метод простой итерации для решения системы нелинейных уравнений.
Единственное отличие такой задачи регрессии от тех, с которыми сталкивается традиционное глубокое обучение — то, что целевая переменная зависит от нашей же собственной модели. Раньше целевые переменные были напрямую источником обучающего сигнала. Теперь же, когда мы хотим выучить будущую награду при условии оптимального поведения, мы не знаем этого истинного значения или даже её стохастичных оценок. Поэтому мы применяем идею бутстрапирования (bootstrapping): берём награду за следующий шаг, и нечестно приближаем всю остальную награду нашей же текущей аппроксимацией
max
max
,θ). Да, за этим кроется идея метода простой итерации, но важно понимать, что такая целевая переменная лишь указывает направление для обучения, но не является истинным приближением будущих наград или даже их несмещённой оценкой. Поэтому говорят, что в этой задаче регрессии очень смещённые (biased) целевые переменные.
На практике из-за этого возникает беда. Наша задача регрессии в таком виде меняется после каждого же шага. Если вдруг после очередного шага оптимизации и обновления весов нейросети наша модель начала выдавать какие-то немного неадекватные значения, они рискуют попасть в целевую переменную на следующем шаге, мы сделаем шаг обучения под неадекватные целевые переменные, модель станет ещё хуже, и так далее, начнётся цепная реакция. Алгоритмы, в которых целевая переменная вот так напрямую зависит от текущей же модели, из-за этого страшно нестабильны.
Для стабилизации применяется трюк, называемый таргет-сетью (target network). Давайте сделаем так, чтобы у нас задача регрессии менялась не после каждого обновления весов нейросетки, а хотя бы раз, скажем, в 1000 шагов оптимизации. Для этого заведём полную копию нашей нейросети («таргет-сеть»), веса которой будем обозначать
θ
−
θ
−
. Каждые 1000 шагов будем копировать веса из нашей модели в таргет-сеть
←θ, больше никак менять
θ
−
θ
−
не будем. Когда мы захотим для очередного перехода
(s,a,r,s
′
) построить таргет, мы воспользуемся не нашей свежей моделью, а таргет-сетью:
y
=
r
+
γ
max
y=r+γ
a
′
max
Тогда правило, по которому строится целевая переменная, будет меняться раз в 1000 шагов, и мы 1000 шагов будем решать одну и ту же задачу регрессии. Такой процесс будет намного стабильнее.
Experience Replay
Чтобы окончательно собрать алгоритм Deep Q-learning (обычно называемый DQN, Deep Q-network), нам понадобится сделать последний шаг, связанный опять со сбором данных. Коли мы хотим обучать нейросетку, нам нужно для каждого обновления весов откуда-то взять целый мини-батч данных, то есть батч переходов
(s,a,r,s
′
), чтобы по нему усреднить оценку градиента. Однако, если мы возьмём среду, сделаем в ней
N
N шагов, то встреченные нами
N
N переходов будут очень похожи друг на друга: они все придут из одной и той же области пространства состояний. Обучение нейросетки на скоррелированных данных — плохая идея, поскольку такая модель быстро забудет, что она учила на прошлых итерациях.
Бороться с этой проблемой можно двумя способами. Первый способ, доступный всегда, когда среда задана при помощи виртуального симулятора — запуск параллельных агентов. Запускается параллельно
N
N процессов взаимодействия агента со средой, и для того, чтобы собрать очередной мини-батч переходов для обучения, во всех экземплярах проводится по одному шагу взаимодействия, собирается по одному переходику. Такой мини-батч уже будет разнообразным.
Более интересный второй способ. Давайте после очередного шага взаимодействия со средой мы не будем тут же использовать переход
(s,a,r,s
′
) для обновления модели, а запомним этот переход и положим его себе в коллекцию. Память со всеми встретившимися в ходе проб и ошибок переходами
(s,a,r,s
′
) называется реплей буфером (replay buffer или experience replay). Теперь для того, чтобы обновить веса нашей сети, мы возьмём и случайно засэмплируем из равномерного распределения желаемое количество переходов из всей истории.
Однако, использование реплей буфера возможно далеко не во всех алгоритмах обучения с подкреплением. Дело в том, что некоторые алгоритмы обучения с подкреплением требуют, чтобы данные для очередного шага обновления весов были сгенерированы именно текущей, самой свежей версией стратегии. Такие алгоритмы относят к классу on-policy: они могут улучшать стратегию только по данным из неё же самой («on policy»). Примером on-policy алгоритмов выступают, например, эволюционные алгоритмы. Как они устроены: например, можно завести популяцию стратегий, поиграть каждой со средой, отобрать лучшие и как-то породить новую популяцию (подробнее про одну из самых успешных схем в рамках такой идеи можно посмотреть здесь). Как бы ни была устроена эта схема, эволюционный алгоритм никак не может использовать данные из, например, старых, плохих стратегий, которые вели себя, скажем, не сильно лучше случайной стратегии. Поэтому неизбежно в эволюционном подходе нужно свежую популяцию отправлять в среду и собирать новые данные перед каждым следующим шагом.
И вот важный момент: Deep Q-learning, как и обычный Q-learning, относится к off-policy алгоритмам обучения с подкреплением. Совершенно неважно, какая стратегия, умная или не очень, старая или новая, породила переход
(s,a,r,s
′
), нам всё равно нужно решать уравнение оптимальности Беллмана в том числе и для этой пары
s
,
a
s,a и нам достаточно при построении таргета лишь чтобы
s
′
s
′
был сэмплом из функции переходов (а она-то как раз одна вне зависимости от того, какая стратегия взаимодействует в среде). Поэтому обновлять модель
(s,a) мы можем по совершенно произвольному опыту, и, значит, мы в том числе можем использовать experience replay.
источник картинки — курс UC Berkeley AI
В любом случае, даже в сложных средах, при взаимодействии со средой мы всё равно должны как-то разрешить дилемму exploration-exploitation, и пользоваться, например,
ε
ε-жадной стратегией исследования. Итак, алгоритм DQN выглядит так:
Проинициализировать нейросеть
(s,a,θ).
Проинициализировать таргет-сеть, положив
=θ.
Пронаблюдать
s
0
s
0
из среды.
Для
k=0,1,2,…:
с вероятностью
ε
ε выбрать действие
a
k
a
k
случайно, иначе жадно:
a
k
=
argmax
=argmax
,θ)
отправить действие
a
k
a
k
в среду, получить награду за шаг
r
k
r
k
и следующее состояние
s
k
+
1
s
k+1
.
добавить переход
k+1
) в реплей буфер.
если в реплей буфере скопилось достаточное число переходиков, провести шаг обучения. Для этого сэмплируем мини-батч переходиков
(s,a,r,s
′
) из буфера.
для каждого переходика считаем целевую переменную:
y
=
r
+
γ
max
y=r+γ
a
′
max
сделать шаг градиентного спуска для обновления
θ
θ, минимизируя
∑(y−Q
∗
(s,a,θ))
2
если
k
k делится на 1000, обновить таргет-сеть:
←θ.
Алгоритм DQN не требует никаких handcrafted признаков или специфических настроек под заданную игру. Один и тот же алгоритм, с одними и теми же гиперпараметрами, можно запустить на любой из 57 игр древней консоли Atari (пример игры в Breakout) и получить какую-то стратегию. Для сравнения алгоритмов RL между собой результаты обычно усредняют по всем 57 играм Atari. Недавно алгоритм под названием Agent57, объединяющий довольно много модификаций и улучшений DQN и развивающий эту идею, смог победить человека сразу во всех этих 57 играх.
А если пространство действий непрерывно?
Всюду в DQN мы предполагали, что пространство действий дискретно и маленькое, чтобы мы могли считать жадную стратегию
π
(
s
)
=
argmax
π(s)=argmax
a
Q
∗
(s,a,θ) и считать максимум в формуле целевой переменной
max
max
a
Q
∗
(s,a,θ). Если пространство действий непрерывно, и на каждом шаге от агента ожидается выбор нескольких вещественных чисел, то как это делать непонятно. Такая ситуация повсюду возникает в робототехнике. Там каждое сочленение робота можно, например, поворачивать вправо / влево, и такие действия проще описывать набором чисел в диапазоне [-1, 1], где -1 — крайне левое положение, +1 — крайне правое, и доступны любые промежуточные варианты. При этом дискретизация действий не вариант из-за экспоненциального взрыва числа вариантов и потери семантики действий. Нам, в общем-то, нужно в DQN только одну проблему решить: как-то научиться аргмаксимум по действиям брать.
А давайте, коли мы не знаем
argmax
argmax
a
Q
∗
(s,a), приблизим его другой нейросеткой. А то есть, заведём вторую нейросеть
π(s,ϕ) с параметрами
ϕ
ϕ, и будем учить её так, чтобы
argmax
π(s,ϕ)≈argmax
a
Q
∗
(s,a,θ).
Как это сделать? Ну, будем на каждой итерации алгоритма брать батч состояний
s
s из нашего реплей буфера и будем учить
π(s,ϕ) выдавать такие действия, на которых наша Q-функция выдаёт большие скалярные значения:
max
(s,π(s,ϕ),θ)→
ϕ
max
Причём, поскольку действия непрерывные, всё слева дифференцируемо и мы можем напрямую применять самый обычный backpropagation!
DDPG
Теперь когда на руках есть приближение
argmax
π(s,ϕ)≈argmax
a
Q
∗
(s,a,θ), можно просто использовать его всюду, где нам нужны аргмаксимумы и максимумы от нашей Q-функции. Мы получили Actor-Critic схему: у нас есть актёр,
π(s,ϕ) — детерминированная стратегия, и критик
(s,a), который оценивает выбор действий актёром и предоставляет градиент для его улучшения. Актёр учится выбирать действия, которые больше всего нравятся критику, а критик учится регрессией с целевой переменной
y
=
r
+
γ
max
y=r+γ
a
′
max
)≈r+γQ
∗
(s
′
,π(s
′
,ϕ),θ
−
)
Эта прикольная рабочая эвристика позволяет придумать off-policy алгоритмы для непрерывных пространств действий; к такому подходу относятся такие алгоритмы, как DDPG, TD3 и SAC.
Policy Gradient алгоритмы
В рассмотренных алгоритмах есть несколько приниципиальных ограничений, которые вытекают непосредственно из самой идеи подхода. Мы учимся с таргетов, заглядывающих всего на один шаг вперёд, использующих только
s
′
s
′
; это чревато проблемой накапливающейся ошибки, поскольку если между выполнением действия и получением награды +1 проходит 100 шагов, нам нужно на сто шагов «распространять» полученный сигнал. Мы должны учить
(s,a) вместо того, чтобы как-то напрямую («end-to-end») запомнить, какие действия в каких состояниях хорошие. Наконец, наша стратегия всегда детерминирована, когда для взаимодействия со средой во время сбора данных, например, нам позарез нужна была стохастичная, чтобы гарантированно обновлять Q-функцию для всех пар
s
,
a
s,a, и эту проблему пришлось закрывать костылями.
Есть второй подход model-free алгоритмов RL, называемый Policy Gradient, который позволяет избежать вышеперечисленных недостатков за счёт on-policy режима работы. Идея выглядит так: давайте будем искать стратегию в классе стохастичных стратегий, то есть заведём нейросеть, моделирующую
(a∣s) напрямую. Тогда наш функционал, который мы оптимизируем,
max
⁡
θ
,
J(θ)=E
T∼π
θ
t≥0
max
,
дифференцируем по параметрам
θ
θ, и градиент равен:
log
J(θ)=E
T∼π
θ
t≥0
∑
∇
θ
logπ
где
R
t
R
t
- reward-to-go с шага
t
t, то есть награда, собранная в сыгранном эпизоде после шага
Эта формула говорит нам, что градиент нашего функционала — это тоже мат.ожидание по траекториям. А значит, мы можем попробовать посчитать какую-то оценку этого градиента, заменив мат.ожидание на Монте Карло оценку, и просто начать оптимизировать наш функционал самым обычным стохастическим градиентным спуском! А то есть: берём нашу стратегию
π
θ
π
θ
с текущими значениями параметров
θ
θ, играем эпизод (или несколько) в среде, то есть сэмплируем
T
∼
π
θ
T∼π
θ
, и затем делаем шаг градиентного подъёма:
log
θ←θ+α
t≥0
∑
∇
θ
logπ
Почему эта идея приводит к on-policy подходу? Для каждого шага градиентного шага нам обязательно нужно взять
T
∼
π
θ
T∼π
θ
с самыми свежими, с текущими весами
θ
θ, и никакая другая траектория, порождённая какой-то другой стратегией, нам не подойдёт. Поэтому для каждой итерации алгоритма нам придётся заново играть очередной эпизод со средой. Это sample-inefficient: неэффективно по числу сэмплов, мы собираем слишком много данных и очень неэффективно с ними работаем.
Policy Gradient алгоритмы пытаются по-разному бороться с этой неэффективностью, опять же обращаясь к теории оценочных функций и бутстрапированным оценкам, позволяющим предсказывать будущие награды, не доигрывая эпизоды целиком до конца. Большинство этих алгоритмов остаются в on-policy режиме и применимы в любых пространствах действий. К этим алгоритмам относятся такие алгоритмы, как Advantage Actor-Critic (A2C), Trust-Region Policy Optimization (TRPO) и Proximal Policy Optimization (PPO).
Что там ещё?
Мы до сих пор разбирали model-free алгоритмы RL, которые обходились без знаний о
p(s
′
∣s,a) и никак не пытались приближать это распределение. Однако, в каких-нибудь пятнашках функция переходов нам известна: мы знаем, в какое состояние перейдёт среда, если мы выберем некоторое действие в таком-то состоянии. Понятно, что эту информацию было бы здорово как-то использовать. Существует обширный класс model-based, который либо предполагает, что функция переходов дана, либо мы учим её приближение, используя
s,a,s
′
из нашего опыта в качестве обучающей выборки. Алгоритм AlphaZero на основе этого подхода превзошёл человека в игру Го, которая считалась куда более сложной игрой, чем шахматы; причём этот алгоритм возможно запустить обучаться на любой игре: как на Го, так и на шахматах или сёги.
источник картинки — курс UC Berkeley AI
Обучение с подкреплением стремится построить алгоритмы, способные обучаться решать любую задачу, представленную в формализме MDP. Как и обычные методы оптимизации, их можно использовать в виде чёрной коробочки из готовых библиотек, например, OpenAI Stable Baselines. Внутри таких коробочек будет, однако, довольно много гиперпараметров, которые пока не совсем понятно как настраивать под ту или иную практическую задачу. И хотя успехи Deep RL демонстрируют, что эти алгоритмы способны обучаться невероятно сложным задачам вроде победы над людьми в Dota 2 и в StarCraft II, они требуют для этого колоссального количества ресурсов. Поиск более эффективных процедур — открытая задача в Deep RL.
В ШАДе есть курс Practical RL, на котором вы погрузитесь глубже в мир глубокого обучения с подкреплением, разберётесь в более продвинутых алгоритмах и попробуете пообучать нейронки решать разные задачки в разных средах.
Знак вопроса
Пройдите квиз по параграфу
Чтобы закрепить пройденный материал
Сообщить об ошибке
Предыдущий параграф
10.5. Задача ранжирования
Следующий параграф
11.2. Краудсорсинг
