---
title: Методы второго порядка
url: https://education.yandex.ru/handbook/ml/article/metody-vtorogo-poryadka
course: ml
chapter: 14. Оптимизация в ML
chapter_id: 14.3
---
В этом разделе мы сконцентрируемся сначала на методах, которые используют информацию о гессиане функции, а затем рассмотрим, как, сохраняя высокоуровневую идею метода Ньютона, обойтись без гессиана.
Метод Ньютона
Итак, наша задача – безусловная оптимизация гладкой функции
f
(
x
)
→
min
f(x)→
x∈R
d
min
.
Как и при оптимизации методом градиентного спуска, мы будем искать направление уменьшения функционала. Но в этот раз мы будем использовать не линейное приближение, а квадратичное:
f(x+Δx)≈f(x)+⟨∇f(x),Δx⟩+
2
1
⟨Δx,B(x)Δx⟩.
Формула Тейлора говорит нам брать
B(x)=∇
2
f(x). Приравняв к нулю градиент этой квадратичной аппроксимации, мы получаем направление спуска для метода Ньютона:
Δx=[B(x)]
−1
∇f(x).
Обозначим
=B(x
k
),H
k
=B
k
−1
. В таком случае мы можем записать итеративный алгоритм спуска:
k+1
∇f(x
k
).
В литературе методом Ньютона называется такой метод при
=1, при другом размере шаге
∈(0,1) этот метод называют дэмпированным (damped) методом Ньютона.
Обсудим, в чем главная особенность метода Ньютона и в чем заключается выигрыш по сравнению с классическим градиентным спуском. Таких особенностей две.
Скорость сходимости метода Ньютона
Первая связана со скоростью его сходимости. А именно – в окрестности решения он сходится квадратично.
Теорема. Пусть функция
f
f имеет достаточно гладкий гессиан и сильно выпукла в точке оптимума
x
∗
x
∗
. Тогда
∃
r
>
0
∃r>0, что для всякого
:∥x
0
−x
∗
∥≤r для метода Ньютона с
=1 верно
k+1
−x
∗
∥≤c∥x
k
−x
∗
∥
2
для константы
c
c зависящей только от
f
f.
Метод Ньютона и плохо обусловленные задачи
Второе приятное свойство заключается в устойчивости метода Ньютона к плохой обусловленности задачи (в отличие от метода градиентного спуска). Разберёмся, что это значит. Когда мы говорим о плохой обусловленности задачи, мы имеем в виду, что гессиан в точке оптимума плохо обусловлен, то есть отношение максимального и минимального собственных чисел является большим числом. Геометрически это значит, что линии уровня функции вблизи оптимума похожи на очень вытянутые эллипсоиды; мы уже обсуждали, что в такой ситуации градиентный спуск может работать медленно. А как справится метод Ньютона? Оказывается, намного лучше. И связано это с его инвариантностью к линейным преобразованиям.
А именно, рассмотрим функцию
(y)=f(Ay) для некоторой невырожденной матрицы
A
A. Обозначим
x
=
A
y
x=Ay. Посмотрим, как связаны градиент и гессиан новой функции с градиентом и гессианом старой. Воспользуемся производной сложной функции:
∇f,
Рассмотрим теперь траекторию
,…,x
K
метода Ньютона, запущенного из точки
x
0
x
0
для поиска минимума функции
f
f, и траекторию
,…,y
K
метода Ньютона, запущенного для поиска минимума функции
f
^
f
^
. Если
=Ay
0
, то для всех
k
k будет верно
=Ay
k
, то есть траектории получаются одна из другой при помощи этого линейного преобразования, другими словами, траектории исходной и новой функции подобны.
Вернёмся теперь к плохо обусловленной задаче минимизации функции
f
f. Рассмотрим линейное преобразование
A=(∇
x
∗
2
f)
−1/2
и функцию
(x)=f(Ax). Тогда для функции
f
^
f
^
число обусловленности гессиана в точке оптимума равно в точность единице (проверьте это!), а траектории для этой новой, хорошо обусловленной функции, и старой, плохо обусловленной, подобны. В частности, метод Ньютона не будет, как градиентный спуск, долго метаться где-то на задворках вытянутой эллиптической «ямки» вокруг оптимума, а быстро ринется к центру.
Можно сказать, что метод Ньютона правильно улавливает кривизну линий уровня функции и это позволяет ему быстрее сходиться к оптимуму. Эту идею стоит запомнить, она появляется в некоторых вдохновлённых методами второго порядка модификациях SGD.
Также еще можно заметить, что свойства, которые мы требуем от функции в теореме о квадратичной сходимости, вообще говоря, не сохраняются при линейных преобразованиях: могут поменяться константы липшицевости и сильной выпуклости. Это простое замечание побудило исследователей ввести класс самосогласованных функций, более широкий и линейно инвариантный, для которого метод Ньютона также сходится. Подробнее об этом можно узнать в разделе 9.6 книги S. Boyd & L. Vandenberghe, Convex Optimization.
Слабости метода Ньютона
От хорошего переходим к плохому: к слабостям метода Ньютона. Во-первых, мы имеем квадратичную скорость сходимости только в окрестности оптимума. А если мы стартуем из произвольно удалённой точки, то нам, как и в случае градиентного спуска, требуется подбор шага
α
k
α
k
при помощи линейного поиска (что нам вряд ли по карману). Если подбирать шаг не хочется, можно прибегнуть к интересному теоретическому методу получения гарантий на глобальную сходимость – добавлению кубической регуляризации.
Другая проблема кроется в формуле пересчета следующей итерации: вычисление и обращение гессиана. Конечно, вместо обращения гессиана можно честно решать систему линейных уравнений, но асимптотика остается прежней:
O
(
d
3
)
O(d
3
), а от затрат памяти на хранение матрицы
O
(
d
2
)
O(d
2
) вообще некуда деться. А это значит, что, например, решать линейную регрессию с ~10000 признаками методом Ньютона попросту невозможно.
Есть и третья, малозаметная проблема: дословно метод Ньютона не работает для невыпуклых задач, поскольку
f(x) не будет положительно опредленной и
Δ
x
Δx перестанет быть направлением спуска. Для решения этой проблемы можно немного «подпортить» нашу аппроксимацию и рассмотреть матрицу вида
f(x
k
)+Δ
k
, такую что
B
k
B
k
станет положительно определенной, и уже её подставлять в нашу квадратичную модель. Идея подмены гессиана на что-то более подходящее – это главная идея квазиньютоновских методов, обсуждаемых далее.
Итак, общие выводы:
Метод Ньютона – теоретически оптимальный метод, который автоматически улавливает кривизну функции в окрестности оптимума.
Для размерности
d
>
1000
d>1000 он уже не является эффективным, поскольку требует вычисления и хранения гессиана, а также решения системы линейных уравнений с его участием (что может быть в общем случае очень дорого).
Квазиньютоновские методы
Чтобы придумать, как бороться с проблемами метода Ньютона, нужно посмотреть на него с другой стороны, а для этого мы обратимся ненадолго к решению задачи нахождения нуля векторной функции.
Метод касательной
Итак, рассмотрим совершенно новую задачу. Пусть дана функция
g:R
n
→R
n
и нужно найти её ноль, то есть такое
x
∗
x
∗
, что
g(x
∗
)=0. Связь с оптимизацией (по крайней мере в выпуклом случае) довольно проста: если взять
g(x)=∇f(x), то корень уравнения
g(x)=0 и будет точкой оптимума.
Сначала рассмотрим одномерный случай
d
=
1
d=1. Как найти ноль функции с помощью итеративной процедуры? Логично поступить следующим образом: проводим касательную
y=g
′
(x
n
)(x−x
n
)+g(x
n
) к графику функции и находим точку
x
n
+
1
x
n+1
, в которой линейная аппроксимация обнуляется:
0=g
′
(x
n
)(x
n+1
−x
n
)+g(x
n
),
откуда получаем формулу пересчета
n+1
g(x
n
)
.
23
Известно, что этот метод обладает квадратичной скоростью сходимости в одномерном мире, что очень перекликается с методом Ньютона для оптимизации – и не просто так.
Если рассмотреть многомерный случай, то вычисление производной заменяется на вычисление якобиана векторнозначной функции
g
g. В случае
g
=
∇
f
g=∇f наш якобиан становится гессианом и получаем в точности обычный метод Ньютона для оптимизации:
n+1
=x
n
−[∇
Метод секущей и общая схема квазиньютоновских методов
Пусть мы хотим найти такую точку
x
∗
x
∗
, что
g(x
∗
)=0. В одномерном случае мы можем подменить вычисление
) вычислением её приближения
g(x
n
)−g(x
n−1
)/(x
n
−x
n−1
). Откуда получаем формулу пересчета:
n+1
=x
n
−
g(x
n
)−g(x
n−1
)
x
n
−x
n−1
g(x
n
)
Графически, этот метод выглядит следующим образом:
23
Скорость сходимости этого метода несколько ниже, чем у метода Ньютона (линейная, а не квадратичная), но зато мы теперь не должны вычислять производную! В текущем виде, используя просто подмену градиента на его конечно-разностную аппроксимацию, не очевидно, как обобщить этот метод на произвольную размерность. Но, если посмотреть на название метода и на картинку, как он работает, мы видим, что мы по сути проводим через два предыдущих приближения секущую, а затем выбираем ноль этой секущей в качестве следующей точки. В многомерном случае мы можем выписать соответствующее ей уравнение
y=B
k
(x−x
k
)+g(x
k
), где
B
k
B
k
– матрица размера
d
×
d
d×d, которая должна удовлетворять так называемому уравнению секущей (secant equation):
k−1
)=g(x
k
)−g(x
k−1
).
Теперь, чтобы выбрать следующую точку, нужно найти ноль секущей, то есть
k+1
−x
k
)+g(x
k
)=0⟺x
k+1
=x
k
−B
k
−1
g(x
k
).
А теперь рассмотрим
g(x)=∇f(x) и добавим в итеративную схему выше размер шага. Тогда мы получаем общую итеративную схему квазиньютоновских методов:
k+1
∇f(x
k
).
При этом необходимо выбирать такие
B
k
B
k
, чтобы они
(а) были симметричными и положительно определенными и
(б) удовлетворяли уравнению секущей
k−1
)=∇f(x
k
)−∇f(x
k−1
)
Первое требование восходит к двум соображениям. Первое –
B
k
B
k
должно приближать гессиан, а он в идеале в окрестности точки минимума как раз является симметричным и положительно определенным. Второе соображение проще: в противном случае
=−B
k
−1
∇f(x
k
) попросту не будет направлением спуска. Несмотря на эти два свойства, выбор по прежнему остается достаточно широким, откуда возникает большое разнообразие квазиньютоновских методов. Мы рассмотрим один классический и широко известный метод BFGS (Broyden, Fletcher, Goldfarb, Shanno).
BFGS
Сначала заметим, что в самом алгоритме в первую очередь используется обратная матрица к
B
k
B
k
, которую мы обозначим
. Тогда выбирать
B
k
B
k
– это тоже самое, что выбирать
H
k
H
k
. Введем еще два стандартных обозначения, чтобы можно было проще записывать все последующие формулы:
k+1
=∇f(x
k+1
)−∇f(x
k
). В их терминах уравнение секущей для
H
k
H
k
выглядит максимально просто:
k−1
=s
k−1
.
Теперь введем некоторое искусственное требование, которое гарантирует единственность
H
k
+
1
H
k+1
– выберем ближайшую подходящую матрицу к
H
k
H
k
, удовлетворяющую описанным выше условиям:
H
k
+
1
=
argmin
k+1
=argmin
H
{
2
1
∥H−H
k
∥
Н=H
⊤
,  Hy
k
=s
k
}
Вообще говоря, при выборе разных норм
∥
⋅
∥
∥⋅∥ мы будем получать разные квазиньютоновские алгоритмы. Рассмотрим один достаточно общий класс норм (аналог взвешенных
ℓ
2
ℓ
2
норм в матричном мире):
∥A∥:=∥W
1/2
AW
1/2
∥
F
,
где
∥
⋅
∥
F
∥⋅∥
F
– это Фробениусова норма
∥C∥
F
2
=⟨C,C⟩
F
=tr(C
⊤
C)=
i,j
W – некоторая симметричная и положительно определенная матрица весов, которую мы выберем таким образом, что она будет сама по себе удовлетворять уравнению секущей
Сразу уточним, что матрица весов в таком случае меняется на каждой итерации и, по сути, на каждой итерации мы имеем разные задачи оптимизации, само же предположение задает дополнительную похожесть на обратный гессиан, поскольку можно взять в качестве весов усредненый гессиан
=[∫
0
1
∇
2
f(x
k
+τα
k
p
k
)dτ]
Решив описанную выше оптимизационную задачу, мы получаем матрицу
H
k
+
1
H
k+1
, не зависящую явным образом от матрицы весов:
Эта формула как раз является ключевой в алгоритме BFGS. Чтобы заметить одно крайне важное свойство этой формулы, раскроем скобки:
k+1
)+ρ
)+ρ
Отсюда мы видим, что нам в этой формуле достаточно умножать матрицу на вектор и складывать матрицы, что можно делать за
O
(
d
2
)
O(d
2
) операций! То есть мы победили один из самых страшных минусов метода Ньютона. Воспользовавшись тем, что
1/ρ
– числа, перепишем формулу в более computational friendly стиле:
k+1
=H
k
+ρ
k
2
(1/ρ
)(s
k
s
k
⊤
)−ρ
Общие выводы:
Итерации BFGS вычислительно проще итераций метода Ньютона и не требуют вычисления гессиана;
По скорости сходимости BFGS уступает методу Ньютона, но все равно является достаточно быстрым;
По прежнему требуется
O
(
d
2
)
O(d
2
) памяти, что по-прежнему вызывает проблемы при большой размерности (
−10
5
).
Время выполнения итерации
O
(
d
2
)
O(d
2
) гораздо лучше, чем
O
(
d
3
)
O(d
3
) метода Ньютона, но всё ещё оставляет желать лучшего.
Казалось бы, избавиться от
O
(
d
2
)
O(d
2
) нельзя принципиально, ведь нужно как-то взаимодействовать с матрицей
H
k
H
k
размера
O
(
d
2
)
O(d
2
), а она не факт что разреженная. Но и в этом случае можно добиться улучшения до линейной сложности (как у градиентных методов!).
L-BFGS
При взаимодействии с матрицами существует два основных способа хранить их дешевле, чем «по-честному». Первый способ – пользоваться разреженностью матрицы, а второй – низкоранговыми разложениями или чем-то близким. Поскольку сейчас мы не хотим добавлять предположений на задачу, которую мы решаем, то единственный выход – это пользоваться структурой
H
k
H
k
, возникающей в BFGS.
Если внимательно взглянуть на формулы обновления, то их можно переписать в следующем виде:
k+1
=V(s
V(s
k
,y
k
)+U(s
V(s
k
,y
k
)=I−ρ
,   U(s
k
,y
k
)=ρ
Для того, чтобы перейти от
k+1
, можно хранить не матрицу
H
k
H
k
, а набор пар из k пар
i=1,…,k
и начальное приближение
H
0
H
0
(например,
=γI для некоторого
γ
>
0
γ>0), чтобы «восстановить»
H
k
H
k
. Пользуясь такой структурой, мы можем хранить матрицу
H
k
+
1
H
k+1
при помощи лишь
(k+1)⋅2d+1 чисел, а не
d
2
d
2
. К сожалению, такая структура имеет довольно простую проблему: при
k
>
d
/
2
k>d/2 затраты памяти становятся только выше.
Возникает простая идея – а давайте хранить только последние
m
=
const
m=const обновлений! Таким образом, мы получаем алгоритм L-BFGS, который имеет уже линейные
O
(
m
d
)
O(md) затраты памяти и, что немаловажно, такие же линейные затраты
O
(
m
d
)
O(md) на итерацию, ведь умножение матриц
V
V и
U
U на вектор может осуществляться за линейное время.
Общие выводы:
L-BFGS обладает линеной сложностью итерации, линейными требованиями по дополнительной памяти и к тому же требует вычислять только градиенты!
Производительность сильно зависит от константы
m
m, отвечающей за точность аппроксимации гессиана;
Как и все методы из этого раздела, требует точного, а не стохастического вычисления градиентов.
Практические аспекты
Из всех перечисленных в этом разделе методов важнее всего отметить L-BFGS как самый практичный. Он реализован в любой* библиотеке, которая имеет дело с оптимизацией чего-либо и может быть эффективным, если удаётся вычислить градиенты (и значения функций для линейного поиска размера шага). К сожалению, это получается не всегда: при больших размерах датасета вычисление честного градиента и значения для функционалов вида суммы
L(X,Y)=
i=1
∑
N
L(x
i
,y
i
)
не представляется возможным за разумное время. В таком случае мы вынуждены вернуться в мир стохастического градиентного спуска. Общая идея более тонкого учёта геометрии линий уровня функции потерь, в чём-то напоминающая происходящее в методе Ньютона, находит применение и в ряде вариаций SGD, но, конечно, порождает совершенно другие методы.
Что же касается самого метода Ньютона, его можно несколько оптимизировать, если смириться с тем, что всё вычисляется неточно. Во-первых, обратную матрицу к гессиану матрицу на самом деле не нужно ни хранить, ни даже вычислять. Давайте разберёмся, почему. Умножить
на вектор
v
v – это то же самое, что решить систему с левой частью
∇
2
f
∇
2
f и правой частью
v
v, а для решения систем уравнений существуют эффективные итеративные методы, не меняющие левой части системы, а требующие лишь уметь умножать её на разные векторы. При этом умножать гессиан на вектор можно при помощи автоматического дифференцирования. Кроме того, можно на кажом шаге неточно решать систему, получая таким образом неточный метод Ньютона. Теория предписывает решать систему все точнее с ростом номера итерации, но на практике нередко используют фиксированное и небольшое число шагов итеративных методов решения систем линейных уравнений.
Знак вопроса
Пройдите квиз по параграфу
Чтобы закрепить пройденный материал
Сообщить об ошибке
Предыдущий параграф
14.2. Проксимальные методы
Как оптимизировать функции потерь с $L_1$-регуляризацией
Следующий параграф
14.4. Сходимость SGD
Почему он всё-таки сходится
