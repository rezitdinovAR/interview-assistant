---
title: Линейные модели
url: https://education.yandex.ru/handbook/ml/article/linear-models
course: ml
chapter: 2. Классическое обучение с учителем
chapter_id: 2.1
---
Линейные модели от линейной до логистической регрессии. Регуляризация, работа с категориальными признаками, многоклассовая классификация
Мы начнем с самых простых и понятных моделей машинного обучения: линейных. В этом параграфе мы разберёмся, что это такое, почему они работают и в каких случаях их стоит использовать. Так как это первый класс моделей, с которым вы столкнётесь, мы постараемся подробно проговорить все важные моменты. Заодно объясним, как работает машинное обучение, на сравнительно простых примерах.
Почему модели линейные?
Представьте, что у вас есть множество объектов
X
X, а вы хотели бы каждому объекту сопоставить какое-то значение. К примеру, у вас есть набор операций по банковской карте, а вы бы хотели, понять, какие из этих операций сделали мошенники. Если вы разделите все операции на два класса и нулём обозначите законные действия, а единицей мошеннические, то у вас получится простейшая задача классификации. Представьте другую ситуацию: у вас есть данные геологоразведки, по которым вы хотели бы оценить перспективы разных месторождений. В данном случае по набору геологических данных ваша модель будет, к примеру, оценивать потенциальную годовую доходность шахты. Это пример задачи регрессии. Числа, которым мы хотим сопоставить объекты из нашего множества иногда называют таргетами (от английского target).
Таким образом, задачи классификации и регрессии можно сформулировать как поиск отображения из множества объектов
X
X в множество возможных таргетов.
Математически задачи можно описать так:
классификация:
X→{0,1,…,K}, где
0
,
…
,
K
0,…,K – номера классов,
регрессия:
X
→
R
X→R.
Очевидно, что просто сопоставить какие-то объекты каким-то числам — дело довольно бессмысленное. Мы же хотим быстро обнаруживать мошенников или принимать решение, где строить шахту. Значит нам нужен какой-то критерий качества. Мы бы хотели найти такое отображение, которое лучше всего приближает истинное соответствие между объектами и таргетами. Что значит «лучше всего» – вопрос сложный. Мы к нему будем много раз возвращаться. Однако, есть более простой вопрос: среди каких отображений мы будем искать самое лучшее? Возможных отображений может быть много, но мы можем упростить себе задачу и договориться, что хотим искать решение только в каком-то заранее заданном параметризированном семействе функций. Весь этот параграф будет посвящен самому простому такому семейству — линейным функциям вида
y=w
1
x
1
+…+w
где
y
y – целевая переменная (таргет),
,…,x
D
) – вектор, соответствующий объекту выборки (вектор признаков), а
,…,w
D
,w
0
– параметры модели. Признаки ещё называют фичами (от английского features). Вектор
w=(w
1
,…,w
D
) часто называют вектором весов, так как на предсказание модели можно смотреть как на взвешенную сумму признаков объекта, а число
w
0
w
0
– свободным коэффициентом, или сдвигом (bias). Более компактно линейную модель можно записать в виде
y=⟨x,w⟩+w
0
Теперь, когда мы выбрали семейство функций, в котором будем искать решение, задача стала существенно проще. Мы теперь ищем не какое-то абстрактное отображение, а конкретный вектор
,…,w
D
)∈R
D+1
.
Замечание. Чтобы применять линейную модель, нужно, чтобы каждый объект уже был представлен вектором численных признаков
,…,x
D
. Конечно, просто текст или граф в линейную модель не положить, придётся сначала придумать для него численные фичи. Модель называют линейной, если она является линейной по этим численным признакам.
Разберёмся, как будет работать такая модель в случае, если
D
=
1
D=1. То есть у наших объектов есть ровно один численный признак, по которому они отличаются. Теперь наша линейная модель будет выглядеть совсем просто:
y=w
1
x
1
+w
0
. Для задачи регрессии мы теперь пытаемся приблизить значение игрек какой-то линейной функцией от переменной икс. А что будет значить линейность для задачи классификации? Давайте вспомним про пример с поиском мошеннических транзакций по картам. Допустим, нам известна ровно одна численная переменная — объём транзакции. Для бинарной классификации транзакций на законные и потенциально мошеннические мы будем искать так называемое разделяющее правило: там, где значение функции положительно, мы будем предсказывать один класс, где отрицательно – другой. В нашем примере простейшим правилом будет какое-то пороговое значение объёма транзакций, после которого есть смысл пометить транзакцию как подозрительную.
1
В случае более высоких размерностей вместо прямой будет гиперплоскость с аналогичным смыслом.
Вопрос на подумать. Если вы посмотрите содержание учебника, то не найдёте в нём ни «полиномиальных» моделей, ни каких-нибудь «логарифмических», хотя, казалось бы, зависимости бывают довольно сложными. Почему так?
Вопрос на подумать. А как быть, если одна из фичей является категориальной, то есть принимает значения из (обычно конечного числа) значений, не являющихся числами? Например, это может быть время года, уровень образования, марка машины и так далее. Как правило, с такими значениями невозможно производить арифметические операции или же результаты их применения не имеют смысла.
Помимо простоты, у линейных моделей есть несколько других достоинств. К примеру, мы можем достаточно легко судить, как влияют на результат те или иные признаки. Скажем, если вес
w
i
w
i
положителен, то с ростом
i
i-го признака таргет в случае регрессии будет увеличиваться, а в случае классификации наш выбор будет сдвигаться в пользу одного из классов. Значение весов тоже имеет прозрачную интерпретацию: чем вес
w
i
w
i
больше, тем «важнее»
i
i-й признак для итогового предсказания. То есть, если вы построили линейную модель, вы неплохо можете объяснить заказчику те или иные её результаты. Это качество моделей называют интерпретируемостью. Оно особенно ценится в индустриальных задачах, цена ошибки в которых высока. Если от работы вашей модели может зависеть жизнь человека, то очень важно понимать, как модель принимает те или иные решения и какими принципами руководствуется. При этом не все методы машинного обучения хорошо интерпретируемы, к примеру, поведение искусственных нейронных сетей или градиентного бустинга интерпретировать довольно сложно.
В то же время слепо доверять весам линейных моделей тоже не стоит по целому ряду причин:
Линейные модели всё-таки довольно узкий класс функций, они неплохо работают для небольших датасетов и простых задач. Однако, если вы решаете линейной моделью более сложную задачу, то вам, скорее всего, придётся выдумывать дополнительные признаки, являющиеся сложными функциями от исходных. Поиск таких дополнительных признаков называется feature engineering, технически он устроен примерно так, как мы описали в вопросе про "полиномиальные модели". Вот только поиском таких искусственных фичей можно сильно увлечься, так что осмысленность интерпретации будет сильно зависеть от здравого смысла эксперта, строившего модель.
Если между признаками есть приближённая линейная зависимость, коэффициенты в линейной модели могут совершенно потерять физический смысл (об этой проблеме и о том, как с ней бороться, мы поговорим дальше, когда будем обсуждать регуляризацию).
Особенно осторожно стоит верить в утверждения вида «этот коэффициент маленький, значит, этот признак не важен». Во-первых, всё зависит от масштаба признака: вдруг коэффициент мал, чтобы скомпенсировать его. Во-вторых, зависимость действительно может быть слабой, но кто знает, в какой ситуации она окажется важна. Такие решения принимаются на основе данных, например, путём проверки статистического критерия (об этом мы коротко упомянем в разделе про вероятностные модели).
Конкретные значения весов могут меняться в зависимости от обучающей выборки, хотя с ростом её размера они будут потихоньку сходиться к весам «наилучшей» линейной модели, которую можно было бы построить по всем-всем-всем данным на свете.
Обсудив немного общие свойства линейных моделей, перейдём к тому, как их всё-таки обучать. Сначала разберёмся с регрессией, а затем настанет черёд классификации.
Линейная регрессия и метод наименьших квадратов (МНК)
Мы начнём с использования линейных моделей для решения задачи регрессии. Простейшим примером постановки задачи линейной регрессии является метод наименьших квадратов (Ordinary least squares).
Пусть у нас задан датасет
(
X
,
y
)
(X,y), где
y=(y
i
)
i=1
N
∈R
N
– вектор значений целевой переменной, а
X=(x
i
)
i=1
N
∈R
N×D
,x
i
∈R
D
– матрица объекты-признаки, в которой
i
i-я строка – это вектор признаков
i
i-го объекта выборки. Мы хотим моделировать зависимость
как линейную функцию со свободным членом. Общий вид такой функции из
R выглядит следующим образом:
)=⟨w,x
i
⟩+w
0
Свободный член
w
0
w
0
часто опускают, потому что такого же результата можно добиться, добавив ко всем
x
i
x
i
признак, тождественно равный единице; тогда роль свободного члена будет играть соответствующий ему вес:
Поскольку это сильно упрощает запись, в дальнейшем мы будем считать, что это уже сделано и зависимость имеет вид просто
)=⟨w,x
i
⟩.
Сведение к задаче оптимизации
Мы хотим, чтобы на нашем датасете (то есть на парах
) из обучающей выборки) функция
f
w
f
w
как можно лучше приближала нашу зависимость.
1
Для того, чтобы чётко сформулировать задачу, нам осталось только одно: на математическом языке выразить желание «приблизить
(x) к
y
y». Говоря простым языком, мы должны научиться измерять качество модели и минимизировать её ошибку, как-то меняя обучаемые параметры. В нашем примере обучаемые параметры — это веса
w
w. Функция, оценивающая то, как часто модель ошибается, традиционно называется функцией потерь, функционалом качества или просто лоссом (loss function). Важно, чтобы её было легко оптимизировать: скажем, гладкая функция потерь – это хорошо, а кусочно постоянная – просто ужасно.
Функции потерь бывают разными. От их выбора зависит то, насколько задачу в дальнейшем легко решать, и то, в каком смысле у нас получится приблизить предсказание модели к целевым значениям. Интуитивно понятно, что для нашей текущей задачи нам нужно взять вектор
y
y и вектор предсказаний модели и как-то сравнить, насколько они похожи. Так как эти вектора «живут» в одном векторном пространстве, расстояние между ними вполне может быть функцией потерь. Более того, положительная непрерывная функция от этого расстояния тоже подойдёт в качестве функции потерь. При этом способов задать расстояние между векторами тоже довольно много. От всего этого разнообразия глаза разбегаются, но мы обязательно поговорим про это позже. Сейчас давайте в качестве лосса возьмём квадрат
L
2
L
2
-нормы вектора разницы предсказаний модели и
y
y. Во-первых, как мы увидим дальше, так задачу будет нетрудно решить, а во-вторых, у этого лосса есть ещё несколько дополнительных свойств:
L
2
L
2
-норма разницы – это евклидово расстояние
∥y−f
w
(x)∥
2
между вектором таргетов и вектором ответов модели, то есть мы их приближаем в смысле самого простого и понятного «расстояния».
Как мы увидим в разделе про вероятностные модели, с точки зрения статистики это соответствует гипотезе о том, что наши данные состоят из линейного «сигнала» и нормально распределенного «шума».
Так вот, наша функция потерь выглядит так:
L(f,X,y)=∥y−f(X)∥
=∥y−Xw∥
2
2
=
i=1
∑
N
(y
i
−⟨x
i
,w⟩)
2
Такой функционал ошибки не очень хорош для сравнения поведения моделей на выборках разного размера. Представьте, что вы хотите понять, насколько качество модели на тестовой выборке из
2500
2500 объектов хуже, чем на обучающей из
5000
5000 объектов. Вы измерили
L
2
L
2
-норму ошибки и получили в одном случае
300
300, а в другом
500
500. Эти числа не очень интерпретируемы. Гораздо лучше посмотреть на среднеквадратичное отклонение
L(f,X,y)=
N
1
i=1
∑
N
(y
i
−⟨x
i
,w⟩)
2
По этой метрике на тестовой выборке получаем
0
,
12
0,12, а на обучающей
0
,
1
0,1.
Функция потерь
i=1
N
(y
i
−⟨x
i
,w⟩)
2
называется Mean Squared Error, MSE или среднеквадратическим отклонением. Разница с
L
2
L
2
-нормой чисто косметическая, на алгоритм решения задачи она не влияет:
MSE
MSE(f,X,y)=
N
1
∥y−Xw∥
2
2
В самом широком смысле, функции работают с объектами множеств: берут какой-то входящий объект из одного множества и выдают на выходе соответствующий ему объект из другого. Если мы имеем дело с отображением, которое на вход принимает функции, а на выходе выдаёт число, то такое отображение называют функционалом. Если вы посмотрите на нашу функцию потерь, то увидите, что это именно функционал. Для каждой конкретной линейной функции, которую задают веса
w
i
w
i
, мы получаем число, которое оценивает, насколько точно эта функция приближает наши значения
y
y. Чем меньше это число, тем точнее наше решение, значит для того, чтобы найти лучшую модель, этот функционал нам надо минимизировать по
min
⁡
w
∥y−Xw∥
2
2
⟶
w
min
Эту задачу можно решать разными способами. В этом параграфе мы сначала решим эту задачу аналитически, а потом приближенно. Сравнение двух этих решений позволит нам проиллюстрировать преимущества того подхода, которому посвящена эта книга. На наш взгляд, это самый простой способ "на пальцах" показать суть машинного обучения.
МНК: точный аналитический метод
Точку минимума можно найти разными способами. Если вам интересно аналитическое решение, вы можете найти его в параграфе про матричные дифференцирования (раздел «Примеры вычисления производных сложных функций»). Здесь же мы воспользуемся геометрическим подходом.
Пусть
(1)
,…,x
(D)
– столбцы матрицы
X
X, то есть столбцы признаков. Тогда
Xw=w
1
x
(1)
+…+w
D
x
(D)
,
и задачу регрессии можно сформулировать следующим образом: найти линейную комбинацию столбцов
(1)
,…,x
(D)
, которая наилучшим способом приближает столбец
y
y по евклидовой норме – то есть найти проекцию вектора
y
y на подпространство, образованное векторами
(1)
,…,x
(D)
.
Разложим
y=y
∥
+y
⊥
, где
=Xw – та самая проекция, а
y
⊥
y
⊥
– ортогональная составляющая, то есть
=y−Xw⊥x
(1)
,…,x
(D)
. Как это можно выразить в матричном виде? Оказывается, очень просто:
(y−Xw)=0
В самом деле, каждый элемент столбца
(y−Xw) – это скалярное произведение строки
X
T
X
T
(=столбца
X
X = одного из
x
(
i
)
x
(i)
) на
y
−
X
w
y−Xw. Из уравнения
(y−Xw)=0 уже очень легко выразить
w=(X
Вопрос на подумать Для вычисления
w
∗
w
∗
нам приходится обращать (квадратную) матрицу
X
T
X
X
T
X, что возможно, только если она невырождена. Что это значит с точки зрения анализа данных? Почему мы верим, что это выполняется во всех разумных ситуациях?
Вычислительная сложность аналитического решения —
O(D
2
N+D
3
), где
N
N — длина выборки,
D
D — число признаков у одного объекта. Слагаемое
N
D
2
ND
2
отвечает за сложность перемножения матриц
X, а слагаемое
D
3
D
3
— за сложность обращения их произведения. Перемножать матрицы
не стоит. Гораздо лучше сначала умножить
y
y на
X
T
X
T
, а затем полученный вектор на
: так будет быстрее и, кроме того, не нужно будет хранить матрицу
Вычисление можно ускорить, используя продвинутые алгоритмы перемножения матриц или итерационные методы поиска обратной матрицы.
Проблемы «точного» решения
Заметим, что для получения ответа нам нужно обратить матрицу
X
T
X
X
T
X. Это создает множество проблем:
Основная проблема в обращении матрицы — это то, что вычислительно обращать большие матрицы дело сложное, а мы бы хотели работать с датасетами, в которых у нас могут быть миллионы точек,
Матрица
X
T
X
X
T
X, хотя почти всегда обратима в разумных задачах машинного обучения, зачастую плохо обусловлена. Особенно если признаков много, между ними может появляться приближённая линейная зависимость, которую мы можем упустить на этапе формулировки задачи. В подобных случаях погрешность нахождения
w
w будет зависеть от квадрата числа обусловленности матрицы
X
X, что очень плохо. Это делает полученное таким образом решение численно неустойчивым: малые возмущения
y
y могут приводить к катастрофическим изменениям
w
w.
Полностью вылечить проблемы мы не сможем, но никто и не обязывает нас останавливаться на «точном» решении (которое всё равно никогда не будет вполне точным). Поэтому ниже мы познакомим вас с совершенно другим методом.
МНК: приближенный численный метод
Минимизируемый функционал является гладким и выпуклым, а это значит, что можно эффективно искать точку его минимума с помощью итеративных градиентных методов. Более подробно вы можете прочитать о них в разделе про методы оптимизации, а здесь мы лишь коротко расскажем об одном самом базовом подходе.
Как известно, градиент функции в точке направлен в сторону её наискорейшего роста, а антиградиент (противоположный градиенту вектор) в сторону наискорейшего убывания. То есть имея какое-то приближение оптимального значения параметра
w
w, мы можем его улучшить, посчитав градиент функции потерь в точке и немного сдвинув вектор весов в направлении антиградиента:
L(f
w
,X,y)
где
α
α – это параметр алгоритма («темп обучения»), который контролирует величину шага в направлении антиградиента. Описанный алгоритм называется градиентным спуском.
Посмотрим, как будет выглядеть градиентный спуск для функции потерь
L(f
w
,X,y)=
N
1
∣∣Xw−y∣∣
2
. Градиент квадрата евклидовой нормы мы уже считали; соответственно,
(Xw−y)
Следовательно, стартовав из какого-то начального приближения, мы можем итеративно уменьшать значение функции, пока не сойдёмся (по крайней мере в теории) к минимуму (вообще говоря, локальному, но в данном случае глобальному).
Алгоритм градиентного спуска
w = random_normal()             # можно пробовать и другие виды инициализации
repeat S times:                 # другой вариант: while abs(err) > tolerance
f = X.dot(w)                 # посчитать предсказание
err = f - y                  # посчитать ошибку
grad = 2 * X.T.dot(err) / N  # посчитать градиент
w -= alpha * grad            # обновить веса
С теоретическими результатами о скорости и гарантиях сходимости градиентного спуска вы можете познакомиться в параграфе про методы оптимизации. Мы позволим себе лишь несколько общих замечаний:
Поскольку задача выпуклая, выбор начальной точки влияет на скорость сходимости, но не настолько сильно, чтобы на практике нельзя было стартовать всегда из нуля или из любой другой приятной вам точки;
Число обусловленности матрицы
X
X существенно влияет на скорость сходимости градиентного спуска: чем более вытянуты эллипсоиды уровня функции потерь, тем хуже;
Темп обучения
α
α тоже сильно влияет на поведение градиентного спуска; вообще говоря, он является гиперпараметром алгоритма, и его, возможно, придётся подбирать отдельно. Другими гиперпараметрами являются максимальное число итераций
S
S и/или порог tolerance.
Вычислительная сложность градиентного спуска –
O(NDS), где, как и выше,
N
N – длина выборки,
D
D – число признаков у одного объекта. Сравните с оценкой
O(D
2
N+D
3
) для «наивного» вычисления аналитического решения.
Сложность по памяти –
O
(
N
D
)
O(ND) на хранение выборки. В памяти мы держим и выборку, и градиент, но в большинстве реалистичных сценариев доминирует выборка.
Стохастический градиентный спуск
На каждом шаге градиентного спуска нам требуется выполнить потенциально дорогую операцию вычисления градиента по всей выборке (сложность
O
(
N
D
)
O(ND)). Возникает идея заменить градиент его оценкой на подвыборке (в английской литературе такую подвыборку обычно именуют batch или mini-batch; в русской разговорной терминологии тоже часто встречается слово батч или мини-батч).
А именно, если функция потерь имеет вид суммы по отдельным парам объект-таргет
L(w,X,y)=
N
1
i=1
∑
N
L(w,x
i
,y
i
),
а градиент, соответственно, записывается в виде
L(w,X,y)=
N
1
i=1
∑
N
∇
w
L(w,x
i
,y
i
),
то предлагается брать оценку
L(w,X,y)≈
B
1
t=1
∑
B
∇
w
L(w,x
для некоторого подмножества этих пар
t=1
B
. Обратите внимание на множители
перед суммами. Почему они нужны? Полный градиент
L(w,X,y) можно воспринимать как среднее градиентов по всем объектам, то есть как оценку матожидания
L(w,x,y); тогда, конечно, оценка матожидания по меньшей подвыборке тоже будет иметь вид среднего градиентов по объектам этой подвыборки.
Как делить выборку на батчи? Ясно, что можно было бы случайным образом сэмплировать их из полного датасета, но даже если использовать быстрый алгоритм вроде резервуарного сэмплирования, сложность этой операции не самая оптимальная. Поэтому используют линейный проход по выборке (которую перед этим лучше всё-таки случайным образом перемешать). Давайте введём ещё один параметр нашего алгоритма: размер батча, который мы обозначим
B
B. Теперь на
B
B очередных примерах вычислим градиент и обновим веса модели. При этом вместо количества шагов алгоритма обычно задают количество эпох
E
E. Это ещё один гиперпараметр. Одна эпоха – это один полный проход нашего сэмплера по выборке. Заметим, что если выборка очень большая, а модель компактная, то даже первый проход бывает можно не заканчивать.
Алгоритм:
w = normal(0, 1)
repeat E times:
for i = B, i <= n, i += B
X_batch = X[i-B : i]
y_batch = y[i-B : i]
f = X_batch.dot(w)                 # посчитать предсказание
err = f - y_batch                  # посчитать ошибку
grad = 2 * X_batch.T.dot(err) / B  # посчитать градиент
w -= alpha * grad
Сложность по времени –
O(NDE). На первый взгляд, она такая же, как и у обычного градиентного спуска, но заметим, что мы сделали в
N
/
B
N/B раз больше шагов, то есть веса модели претерпели намного больше обновлений.
Сложность по памяти можно довести до
O
(
B
D
)
O(BD): ведь теперь всю выборку не надо держать в памяти, а достаточно загружать лишь текущий батч (а остальная выборка может лежать на диске, что удобно, так как в реальности задачи, в которых выборка целиком не влезает в оперативную память, встречаются сплошь и рядом). Заметим, впрочем, что при этом лучше бы
B
B взять побольше: ведь чтение с диска – намного более затратная по времени операция, чем чтение из оперативной памяти.
В целом, разницу между алгоритмами можно представлять как-то так:
1
Шаги стохастического градиентного спуска заметно более шумные, но считать их получается значительно быстрее. В итоге они тоже сходятся к оптимальному значению из-за того, что матожидание оценки градиента на батче равно самому градиенту. По крайней мере, сходимость можно получить при хорошо подобранных коэффициентах темпа обучения в случае выпуклого функционала качества. Подробнее мы об этом поговорим в параграфе про оптимизацию. Для сложных моделей и лоссов стохастический градиентный спуск может сходиться плохо или застревать в локальных минимумах, поэтому придумано множество его улучшений. О некоторых из них также рассказано в параграфе про оптимизацию.
Существует определённая терминологическая путаница, иногда стохастическим градиентным спуском называют версию алгоритма, в которой размер батча равен единице (то есть максимально шумная и быстрая версия алгоритма), а версии с бОльшим размером батча называют batch gradient descent. В книгах, которые, возможно, старше вас, такая процедура иногда ещё называется incremental gradient descent. Это не очень принципиально, но вы будьте готовы, если что.
Вопрос на подумать. Вообще говоря, если объём данных не слишком велик и позволяет это сделать, объекты лучше случайным образом перемешивать перед тем, как подавать их в алгоритм стохастического градиентного спуска. Как вам кажется, почему?
Также можно использовать различные стратегии отбора объектов. Например, чаще брать объекты, на которых ошибка больше. Какие ещё стратегии вы могли бы придумать?
Неградиентные методы
После прочтения этой главы у вас может сложиться ощущение, что приближённые способы решения ML задач и градиентные методы – это одно и тоже, но вы будете правы в этом только на 98%. В принципе, существуют и другие способы численно решать эти задачи, но в общем случае они работают гораздо хуже, чем градиентный спуск, и не обладают таким хорошим теоретическим обоснованием. Мы не будем рассказывать про них подробно, но можете на досуге почитать, скажем, про Stepwise regression, Orthogonal matching pursuit или LARS. У LARS, кстати, есть довольно интересное свойство: он может эффективно работать на выборках, в которых число признаков больше числа примеров. С алгоритмом LARS вы можете познакомиться в параграфе про оптимизацию.
Регуляризация
Всегда ли решение задачи регрессии единственно? Вообще говоря, нет. Так, если в выборке два признака будут линейно зависимы (и следовательно, ранг матрицы будет меньше
D
D), то гарантировано найдётся такой вектор весов
ν
ν что
⟨ν,x
i
⟩=0  ∀x
i
. В этом случае, если какой-то
w
w является решением оптимизационной задачи, то и
w
+
α
ν
w+αν тоже является решением для любого
α
α. То есть решение не только не обязано быть уникальным, так ещё может быть сколь угодно большим по модулю. Это создаёт вычислительные трудности. Малые погрешности признаков сильно возрастают при предсказании ответа, а в градиентном спуске накапливается погрешность из-за операций со слишком большими числами.
Конечно, в жизни редко бывает так, что признаки строго линейно зависимы, а вот быть приближённо линейно зависимыми они вполне могут быть. Такая ситуация называется мультиколлинеарностью. В этом случае у нас, всё равно, возникают проблемы, близкие к описанным выше. Дело в том, что
X
ν
∼
0
Xν∼0 для вектора
ν
ν, состоящего из коэффициентов приближённой линейной зависимости, и, соответственно,
Xν≈0, то есть матрица
X
T
X
X
T
X снова будет близка к вырожденной. Как и любая симметричная матрица, она диагонализуется в некотором ортонормированном базисе, и некоторые из собственных значений
λ
i
λ
i
близки к нулю. Если вектор
X
T
y
X
T
y в выражении
y будет близким к соответствующему собственному вектору, то он будет умножаться на
1
/
λ
i
1/λ
i
, что опять же приведёт к появлению у
w
w очень больших по модулю компонент (при этом
w
w ещё и будет вычислен с большой погрешностью из-за деления на маленькое число). И, конечно же, все ошибки и весь шум, которые имелись в матрице
X
X, при вычислении
y
∼
X
w
y∼Xw будут умножаться на эти большие и неточные числа и возрастать во много-много раз, что приведёт к проблемам, от которых нас не спасёт никакое сингулярное разложение.
Важно ещё отметить, что в случае, когда несколько признаков линейно зависимы, веса
w
i
w
i
при них теряют физический смысл. Может даже оказаться, что вес признака, с ростом которого таргет, казалось бы, должен увеличиваться, станет отрицательным. Это делает модель не только неточной, но и принципиально не интерпретируемой. Вообще, неадекватность знаков или величины весов – хорошее указание на мультиколлинеарность.
Для того, чтобы справиться с этой проблемой, задачу обычно регуляризуют, то есть добавляют к ней дополнительное ограничение на вектор весов. Это ограничение можно, как и исходный лосс, задавать по-разному, но, как правило, ничего сложнее, чем
L
1
L
1
- и
L
2
L
2
-нормы, не требуется.
Вместо исходной задачи теперь предлагается решить такую:
min
min
min
L(f,X,y)=
w
min
(∥Xw−y∥
2
2
+λ∥w∥
k
k
)
λ
λ – это очередной параметр, а
∥w∥
k
ˆ
k
– это один из двух вариантов:
∥w∥
2
2
=w
1
2
+…+w
D
2
или
∥w∥
1
1
=∣w
1
∣+…+∣w
D
∣
Добавка
λ∥w∥
k
k
называется регуляризационным членом или регуляризатором, а число
λ
λ – коэффициентом регуляризации.
Коэффициент
λ
λ является гиперпараметром модели и достаточно сильно влияет на качество итогового решения. Его подбирают по логарифмической шкале (скажем, от 1e-2 до 1e+2), используя для сравнения моделей с разными значениями
λ
λ дополнительную валидационную выборку. При этом качество модели с подобранным коэффициентом регуляризации уже проверяют на тестовой выборке, чтобы исключить переобучение. Более подробно о том, как нужно подбирать гиперпараметры, вы можете почитать в соответствующем параграфе.
Отдельно надо договориться о том, что вес
w
0
w
0
, соответствующий отступу от начала координат (то есть признаку из всех единичек), мы регуляризовать не будем, потому что это не имеет смысла: если даже все значения
y
y равномерно велики, это не должно портить качество обучения. Обычно это не отображают в формулах, но если придираться к деталям, то стоило бы написать сумму по всем весам, кроме
∥w∥
2
2
=
j=1
∥w∥
1
=
j=1
∑
D
∣w
j
∣
В случае
L
2
L
2
-регуляризации решение задачи изменяется не очень сильно. Например, продифференцировав новый лосс по
w
w, легко получить, что «точное» решение имеет вид:
w=(X
T
X+λI)
−1
X
T
y
Отметим, что за этой формулой стоит и понятная численная интуиция: раз матрица
X
T
X
X
T
X близка к вырожденной, то обращать её сродни самоубийству. Мы лучше слегка исказим её добавкой
λ
I
λI, которая увеличит все собственные значения на
λ
λ, отодвинув их от нуля. Да, аналитическое решение перестаёт быть «точным», но за счёт снижения численных проблем мы получим более качественное решение, чем при использовании «точной» формулы.
В свою очередь, градиент функции потерь
L(f
w
,X,y)=∥Xw−y∥
2
+λ∥w∥
2
по весам теперь выглядит так:
L(f
w
,X,y)=2X
T
(Xw−y)+2λw
Подставив этот градиент в алгоритм стохастического градиентного спуска, мы получаем обновлённую версию приближенного алгоритма, отличающуюся от старой только наличием дополнительного слагаемого.
Вопрос на подумать. Рассмотрим стохастический градиентный спуск для
L
2
L
2
-регуляризованной линейной регрессии с батчами размера
1
1. Выберите правильный вариант шага SGD:
(а)
−2α(⟨w,x
j
⟩−y
j
)x
ji
−
N
2αλ
w
i
,i=1,…,D;
(б)
−2α(⟨w,x
j
⟩−y
j
)x
ji
−2αλw
i
,i=1,…,D;
(в)
−2α(⟨w,x
j
⟩−y
j
)x
ji
−2λNw
i
,i=1,…D.
Вопрос на подумать. Распишите процедуру стохастического градиентного спуска для
L
1
L
1
-регуляризованной линейной регрессии. Как вам кажется, почему никого не волнует, что функция потерь, строго говоря, не дифференцируема?
Отметим, что
L
1
L
1
- и
L
2
L
2
-регуляризацию можно определять для любой функции потерь
L(w,X,y) (и не только в задаче регрессии, а и, например, в задаче классификации тоже). Новая функция потерь будет соответственно равна
(w,X,y)=L(w,X,y)+λ∥w∥
1
или
(w,X,y)=L(w,X,y)+λ∥w∥
2
2
Разреживание весов в
L
1
L
1
-регуляризации
L
2
L
2
-регуляризация работает прекрасно и используется в большинстве случаев, но есть одна полезная особенность
L
1
L
1
-регуляризации: её применение приводит к тому, что у признаков, которые не оказывают большого влияния на ответ, вес в результате оптимизации получается равным
0
0. Это позволяет удобным образом удалять признаки, слабо влияющие на таргет. Кроме того, это даёт возможность автоматически избавляться от признаков, которые участвуют в соотношениях приближённой линейной зависимости, соответственно, спасает от проблем, связанных с мультиколлинеарностью, о которых мы писали выше.
Не очень строгим, но довольно интуитивным образом это можно объяснить так:
В точке оптимума линии уровня регуляризационного члена касаются линий уровня основного лосса, потому что, во-первых, и те, и другие выпуклые, а во-вторых, если они пересекаются трансверсально, то существует более оптимальная точка:
1
Линии уровня
L
1
L
1
-нормы – это
N
N-мерные октаэдры. Точки их касания с линиями уровня лосса, скорее всего, лежат на грани размерности, меньшей
N
−
1
N−1, то есть как раз в области, где часть координат равна нулю:
1
Заметим, что данное построение говорит о том, как выглядит оптимальное решение задачи, но ничего не говорит о способе, которым это решение можно найти. На самом деле, найти такой оптимум непросто: у
L
1
L
1
меры довольно плохая производная. Однако, способы есть. Можете на досуге прочитать, например, вот эту статью о том, как работало предсказание CTR в google в 2012 году. Там этой теме посвящается довольно много места. Кроме того, рекомендуем посмотреть про проксимальные методы в разделе этой книги про оптимизацию в ML.
Заметим также, что вообще-то оптимизация любой нормы
, 0<x≤1, приведёт к появлению разреженных векторов весов, просто если c
L
1
L
1
ещё хоть как-то можно работать, то с остальными всё будет ещё сложнее.
Другие лоссы
Стохастический градиентный спуск можно очевидным образом обобщить для решения задачи линейной регрессии с любой другой функцией потерь, не только квадратичной: ведь всё, что нам нужно от неё, – это чтобы у функции потерь был градиент. На практике это делают редко, но тем не менее рассмотрим ещё пару вариантов.
MAE
Mean absolute error, абсолютная ошибка, появляется при замене
L
2
L
2
нормы в MSE на
MAE(y,
y
)=
N
1
i=1
Можно заметить, что в MAE по сравнению с MSE существенно меньший вклад в ошибку будут вносить примеры, сильно удалённые от ответов модели. Дело тут в том, что в MAE мы считаем модуль расстояния, а не квадрат, соответственно, вклад больших ошибок в MSE получается существенно больше. Такая функция потерь уместна в случаях, когда вы пытаетесь обучить регрессию на данных с большим количеством выбросов в таргете.
Иначе на эту разницу можно посмотреть так: MSE приближает матожидание условного распределения
y
∣
x
y∣x, а MAE – медиану.
MAPE
Mean absolute percentage error, относительная ошибка.
MAPE(y,
y
)=
N
1
i=1
Часто используется в задачах прогнозирования (например, погоды, загруженности дорог, кассовых сборов фильмов, цен), когда ответы могут быть различными по порядку величины, и при этом мы бы хотели верно угадать порядок, то есть мы не хотим штрафовать модель за предсказание 2000 вместо 1000 в разы сильней, чем за предсказание 2 вместо 1.
Вопрос на подумать. Кроме описанных выше в задаче линейной регрессии можно использовать и другие функции потерь, например, Huber loss:
где
L(f,X,y)=
i=1
−⟨w
i
,x⟩), где h
δ
(z)={
2
1
z
2
,∣z∣⩽δ
δ(∣z∣−
2
1
δ),∣z∣>δ
Число
δ
δ является гиперпараметром. Сложная формула при
∣
z
∣
>
δ
∣z∣>δ нужна, чтобы функция
(z) была непрерывной. Попробуйте объяснить, зачем может быть нужна такая функция потерь.
Линейная классификация
Теперь давайте поговорим про задачу классификации. Для начала будем говорить про бинарную классификацию на два класса. Обобщить эту задачу до задачи классификации на
K
K классов не составит большого труда. Пусть теперь наши таргеты
y
y кодируют принадлежность к положительному или отрицательному классу, то есть принадлежность множеству
{−1,1} (в этом параграфе договоримся именно так обозначать классы, хотя в жизни вам будут нередко встречаться и метки
{
0
,
1
}
{0,1}), а
x
x – по-прежнему векторы из
R
D
R
D
. Мы хотим обучить линейную модель так, чтобы плоскость, которую она задаёт, как можно лучше отделяла объекты одного класса от другого.
1
В идеальной ситуации найдётся плоскость, которая разделит классы: положительный окажется с одной стороны от неё, а отрицательный с другой. Выборка, для которой это возможно, называется линейно разделимой. Увы, в реальной жизни такое встречается крайне редко.
Как обучить линейную модель классификации, нам ещё предстоит понять, но уже ясно, что итоговое предсказание можно будет вычислить по формуле
y
=
sign
y=sign⟨w,x
i
⟩
Сконструируем теперь функционал ошибки так, чтобы он вышеперечисленными проблемами не обладал. Мы хотим минимизировать число ошибок классификатора, то есть
min
⁡
w
i
∑
I[y
i

=sign⟨w,x
i
⟩]⟶
w
min
Домножим обе части на
y
i
y
i
и немного упростим
min
⁡
w
i
∑
I[y
i
⟨w,x
i
⟩<0]⟶
w
min
Величина
M=y
i
⟨w,x
i
⟩ называется отступом (margin) классификатора. Такая фунция потерь называется misclassification loss. Легко видеть, что
отступ положителен, когда
sign(y
i
)=sign(⟨w,x
i
⟩), то есть класс угадан верно; при этом чем больше отступ, тем больше расстояние от
x
i
x
i
до разделяющей гиперплоскости, то есть «уверенность классификатора»;
отступ отрицателен, когда
sign(y
i
)

=sign(⟨w,x
i
⟩), то есть класс угадан неверно; при этом чем больше по модулю отступ, тем более сокрушительно ошибается классификатор.
От каждого из отступов мы вычисляем функцию
F(M)=I[M<0]={
1, M<0,
0, M⩾0
Она кусочно-постоянная, и из-за этого всю сумму невозможно оптимизировать градиентными методами: ведь её производная равна нулю во всех точках, где она существует. Но мы можем мажорировать её какой-нибудь более гладкой функцией, и тогда задачу можно будет решить. Функции можно использовать разные, у них свои достоинства и недостатки, давайте рассмотрим несколько примеров:
1
Вопрос на подумать. Допустим, мы как-то обучили классификатор, и подавляющее большинство отступов оказались отрицательными. Правда ли нас постигла катастрофа?
Вопрос на подумать. Предположим, что у нас есть два классификатора с примерно одинаковыми и достаточно приемлемыми значениями интересующей нас метрики. При этом одна почти всегда выдаёт предсказания с большими по модулю отступами, а вторая – с относительно маленькими. Верно ли, что первая модель лучше, чем вторая?
Ошибка перцептрона
Реализуем простейшую идею: давайте считать отступы только на неправильно классифицированных объектах и учитывать их не бинарно, а линейно, пропорционально их размеру. Получается такая функция:
F
(
M
)
=
max
F(M)=max(0,−M)
Давайте запишем такой лосс с
L
2
L
2
-регуляризацией:
max
L(w,x,y)=λ∣∣w∣∣
2
2
+
i
∑
max(0,−y
i
⟨w,x
i
⟩)
Найдём градиент:
L(w,x,y)=2λw+
⟨w,x
i
⟩>0
y
i
⟨w,x
i
⟩≤0
Имея аналитическую формулу для градиента, мы теперь можем так же, как и раньше, применить стохастический градиентный спуск, и задача будет решена.
Данная функция потерь впервые была предложена для перцептрона Розенблатта, первой вычислительной модели нейросети, которая в итоге привела к появлению глубокого обучения.
Она решает задачу линейной классификации, но у неё есть одна особенность: её решение не единственно и сильно зависит от начальных параметров. Например, все изображённые ниже классификаторы имеют одинаковый нулевой лосс:
1
Hinge loss, SVM
Для таких случаев, как на картинке выше, возникает логичное желание не только найти разделяющую прямую, но и постараться провести её на одинаковом удалении от обоих классов, то есть максимизировать минимальный отступ:
1
Это можно сделать, слегка поменяв функцию ошибки, а именно положив её равной:
F
(
M
)
=
max
F(M)=max(0,1−M)
max
L(w,x,y)=λ∥∣w∥∣
2
2
+
i
∑
max(0,1−y
i
⟨w,x
L(w,x,y)=2λw+
1−y
i
⟨w,x
i
⟩≤0
1−y
i
⟨w,x
i
⟩>0
Почему же добавленная единичка приводит к желаемому результату?
Интуитивно это можно объяснить так: объекты, которые проклассифицированы правильно, но не очень "уверенно" (то есть
0≤y
i
⟨w,x
i
⟩<1), продолжают вносить свой вклад в градиент и пытаются "отодвинуть" от себя разделяющую плоскость как можно дальше.
К данному выводу можно прийти и чуть более строго; для этого надо совершенно по-другому взглянуть на выражение, которое мы минимизируем. Поможет вот эта картинка:
1
Если мы максимизируем минимальный отступ, то надо максимизировать
2
∥
w
∥
2
∥w∥
2
2
, то есть ширину полосы при условии того, что большинство объектов лежат с правильной стороны, что эквивалентно решению нашей исходной задачи:
max
min
⁡
w
λ∥w∥
2
2
+
i
∑
max(0,1−y
i
⟨w,x
i
⟩)⟶
w
min
Отметим, что первое слагаемое у нас обратно пропорционально ширине полосы, но мы и максимизацию заменили на минимизацию, так что тут всё в порядке. Второе слагаемое – это штраф за то, что некоторые объекты неправильно расположены относительно разделительной полосы. В конце концов, никто нам не обещал, что классы наши линейно разделимы и можно провести оптимальную плоскость вообще без ошибок.
Итоговое положение плоскости задаётся всего несколькими обучающими примерами. Это ближайшие к плоскости правильно классифицированные объекты, которые называют опорными векторами или support vectors. Весь метод, соответственно, зовётся методом опорных векторов, или support vector machine, или сокращённо SVM. Начиная с шестидесятых годов это был сильнейший из известных методов машинного обучения. В девяностые его сменили методы, основанные на деревьях решений, которые, в свою очередь, недавно передали «пальму первенства» нейросетям.
Почему же SVM был столь популярен? Из-за небольшого количества параметров и доказуемой оптимальности. Сейчас для нас нормально выбирать специальный алгоритм под задачу и подбирать оптимальные гиперпараметры для этого алгоритма перебором, а когда-то трава была зеленее, а компьютеры медленнее, и такой роскоши у людей не было. Поэтому им нужны были модели, которые гарантированно неплохо работали бы в любой ситуации. Такой моделью и был SVM.
Другие замечательные свойства SVM: существование уникального решения и доказуемо минимальная склонность к переобучению среди всех популярных классов линейных классификаторов. Кроме того, несложная модификация алгоритма, ядровый SVM, позволяет проводить нелинейные разделяющие поверхности.
Строгий вывод постановки задачи SVM можно прочитать тут или в лекции К.В. Воронцова.
Логистическая регрессия
В этом параграфе мы будем обозначать классы нулём и единицей.
Ещё один интересный метод появляется из желания посмотреть на классификацию как на задачу предсказания вероятностей. Хороший пример – предсказание кликов в интернете (например, в рекламе и поиске). Наличие клика в обучающем логе не означает, что, если повторить полностью условия эксперимента, пользователь обязательно кликнет по объекту опять. Скорее у объектов есть какая-то "кликабельность", то есть истинная вероятность клика по данному объекту. Клик на каждом обучающем примере является реализацией этой случайной величины, и мы считаем, что в пределе в каждой точке отношение положительных и отрицательных примеров должно сходиться к этой вероятности.
Проблема состоит в том, что вероятность, по определению, величина от 0 до 1, а простого способа обучить линейную модель так, чтобы это ограничение соблюдалось, нет. Из этой ситуации можно выйти так: научить линейную модель правильно предсказывать какой-то объект, связанный с вероятностью, но с диапазоном значений
(−∞,∞), и преобразовать ответы модели в вероятность. Таким объектом является logit или log odds – логарифм отношения вероятности положительного события к отрицательному
log
log(
1−p
p
).
Если ответом нашей модели является
log
log(
1−p
p
), то искомую вероятность посчитать не трудно:
log
⟨w,x
i
⟩=log(
1−p
⟨w,x
i
⟩
=
1−p
1+e
−⟨w,x
i
⟩
1
Функция в правой части называется сигмоидой и обозначается
σ(z)=
1+e
−z
1
Таким образом,
p=σ(⟨w,x
i
⟩)
Как теперь научиться оптимизировать
w
w так, чтобы модель как можно лучше предсказывала логиты? Нужно применить метод максимума правдоподобия для распределения Бернулли. Это самое простое распределение, которое возникает, к примеру, при бросках монетки, которая орлом выпадает с вероятностью
p
p. У нас только событием будет не орёл, а то, что пользователь кликнул на объект с такой вероятностью. Если хотите больше подробностей, почитайте про распределение Бернулли в теоретическом минимуме.
Правдоподобие позволяет понять, насколько вероятно получить данные значения таргета
y
y при данных
X
X и весах
w
w. Оно имеет вид
p(y∣X,w)=
i
∏
p(y
i
∣x
i
,w)
и для распределения Бернулли его можно выписать следующим образом:
p(y∣X,w)=
(1−p
i
)
1−y
i
где
p
i
p
i
– это вероятность, посчитанная из ответов модели. Оптимизировать произведение неудобно, хочется иметь дело с суммой, так что мы перейдём к логарифмическому правдоподобию и подставим формулу для вероятности, которую мы получили выше:
log
log
ℓ(w,X,y)=
i
∑
(y
i
log(p
i
)+(1−y
i
)log(1−p
i
))=
log
log
log(σ(⟨w,x
i
⟩))+(1−y
i
)log(1−σ(⟨w,x
i
⟩)))
Если заметить, что
σ(−z)=
1+e
=1−σ(z),
то выражение можно переписать проще:
log
log
ℓ(w,X,y)=
i
∑
(y
i
log(σ(⟨w,x
i
⟩))+(1−y
i
)log(σ(−⟨w,x
i
⟩)))
Нас интересует
w
w, для которого правдоподобие максимально. Чтобы получить функцию потерь, которую мы будем минимизировать, умножим его на минус один:
log
log
L(w,X,y)=−
i
∑
(y
i
log(σ(⟨w,x
i
⟩))+(1−y
i
)log(σ(−⟨w,x
i
⟩)))
В отличие от линейной регрессии, для логистической нет явной формулы решения. Деваться некуда, будем использовать градиентный спуск. К счастью, градиент устроен очень просто:
L(y,X,w)=−
−σ(⟨w,x
i
⟩))
Предсказание модели будет вычисляться, как мы договаривались, следующим образом:
p=σ(⟨w,x
i
⟩)
Это вероятность положительного класса, а как от неё перейти к предсказанию самого класса? В других методах нам достаточно было посчитать знак предсказания, но теперь все наши предсказания положительные и находятся в диапазоне от 0 до 1. Что же делать? Интуитивным и не совсем (и даже совсем не) правильным является ответ «взять порог 0.5». Более корректным будет подобрать этот порог отдельно, для уже построенной регрессии минимизируя нужную вам метрику на отложенной тестовой выборке. Например, сделать так, чтобы доля положительных и отрицательных классов примерно совпадала с реальной.
Отдельно заметим, что метод называется логистической регрессией, а не логистической классификацией именно потому, что предсказываем мы не классы, а вещественные числа – логиты.
Вопрос на подумать. Проверьте, что, если метки классов – это
±
1
±1, а не
0
0 и
1
1, то функцию потерь для логистической регрессии можно записать в более компактном виде:
log
L(w,X,y)=
i=1
∑
N
log(1+e
−y
i
⟨w,x
i
⟩
)
Вопрос на подумать. Правда ли разделяющая поверхность модели логистической регрессии является гиперплоскостью?
Вопрос на подумать. Допустим, что матрица объекты-признаки
X
X имеет полный ранг по столбцам (то есть все её столбцы линейно независимы). Верно ли, что решение задачи восстановления логистической регрессии единственно?
Вопрос на подумать. На картинке ниже представлены результаты работы на одном и том же датасете трёх моделей логистической регрессии с разными коэффициентами
L
2
L
2
-регуляризации:
1
Наверху показаны предсказанные вероятности положительного класса, внизу – вид разделяющей поверхности.
Как вам кажется, какие картинки соответствуют самому большому коэффициенту регуляризации, а какие – самому маленькому? Почему?
Многоклассовая классификация
В этом разделе мы будем следовать изложению из лекций Евгения Соколова.
Пусть каждый объект нашей выборки относится к одному из
K
K классов:
Y={1,…,K}. Чтобы предсказывать эти классы с помощью линейных моделей, нам придётся свести задачу многоклассовой классификации к набору бинарных, которые мы уже хорошо умеем решать. Мы разберём два самых популярных способа это сделать – one-vs-all и all-vs-all, а проиллюстрировать их нам поможет вот такой игрушечный датасет
1
Один против всех (one-versus-all)
Обучим
K
K линейных классификаторов
(x),…,b
K
(x), выдающих оценки принадлежности классам
1
,
…
,
K
1,…,K соответственно. В случае с линейными моделями эти классификаторы будут иметь вид
sgn
(x)=sgn(⟨w
k
,x⟩+w
0k
)
Классификатор с номером
k
k будем обучать по выборке
,2I[y
i
=k]−1)
i=1
N
; иными словами, мы учим классификатор отличать
k
k-й класс от всех остальных.
Логично, чтобы итоговый классификатор выдавал класс, соответствующий самому уверенному из бинарных алгоритмов. Уверенность можно в каком-то смысле измерить с помощью значений линейных функций:
a
(
x
)
=
argmax
a(x)=argmax
k
(⟨w
k
,x⟩+w
0k
)
Давайте посмотрим, что даст этот подход применительно к нашему датасету. Обучим три линейных модели, отличающих один класс от остальных:
1
Теперь сравним значения линейных функций
1
и для каждой точки выберем тот класс, которому соответствует большее значение, то есть самый «уверенный» классификатор:
1
Хочется сказать, что самый маленький класс «обидели».
Проблема данного подхода заключается в том, что каждый из классификаторов
(x),…,b
K
(x) обучается на своей выборке, и значения линейных функций
,x⟩+w
0k
или, проще говоря, "выходы" классификаторов могут иметь разные масштабы. Из-за этого сравнивать их будет неправильно. Нормировать вектора весов, чтобы они выдавали ответы в одной и той же шкале, не всегда может быть разумным решением: так, в случае с SVM веса перестанут являться решением задачи, поскольку нормировка изменит норму весов.
Все против всех (all-versus-all)
Обучим
классификаторов
(x),
i,j=1,…,K,
i
≠
j
i

=j. Например, в случае с линейными моделями эти модели будут иметь вид
sgn
(x)=sgn(⟨w
ij
,x⟩+w
0,ij
)
Классификатор
(x) будем настраивать по подвыборке
⊂X, содержащей только объекты классов
i
i и
j
j. Соответственно, классификатор
(x) будет выдавать для любого объекта либо класс
i
i, либо класс
j
j. Проиллюстрируем это для нашей выборки:
1
Чтобы классифицировать новый объект, подадим его на вход каждого из построенных бинарных классификаторов. Каждый из них проголосует за свой класс; в качестве ответа выберем тот класс, за который наберется больше всего голосов:
a
(
x
)
=
argmax
a(x)=argmax
k
i=1
I[a
ij
(x)=k]
Для нашего датасета получается следующая картинка:
1
Обратите внимание на серый треугольник на стыке областей. Это точки, для которых голоса разделились (в данном случае каждый классификатор выдал какой-то свой класс, то есть у каждого класса было по одному голосу). Для этих точек нет явного способа выдать обоснованное предсказание.
Многоклассовая логистическая регрессия
Некоторые методы бинарной классификации можно напрямую обобщить на случай многих классов. Выясним, как это можно проделать с логистической регрессией.
В логистической регрессии для двух классов мы строили линейную модель
b(x)=⟨w,x⟩+w
0
,
а затем переводили её прогноз в вероятность с помощью сигмоидной функции
exp
⁡
(
−
z
)
σ(z)=
1+exp(−z)
1
. Допустим, что мы теперь решаем многоклассовую задачу и построили
K
K линейных моделей
(x)=⟨w
k
,x⟩+w
0k
,
каждая из которых даёт оценку принадлежности объекта одному из классов. Как преобразовать вектор оценок
(x),…,b
K
(x)) в вероятности? Для этого можно воспользоваться оператором
softmax
softmax(z
1
,…,z
K
), который производит «нормировку» вектора:
softmax
exp
exp
exp
exp
softmax(z
1
,…,z
K
)=(
∑
k=1
K
exp(z
k
)
exp(z
1
)
,…,
∑
k=1
K
exp(z
k
)
exp(z
K
)
).
В этом случае вероятность
k
k-го класса будет выражаться как
exp
exp
P(y=k∣x,w)=
∑
j=1
K
exp(⟨w
j
,x⟩+w
0j
)
exp(⟨w
k
,x⟩+w
0k
)
.
Обучать эти веса предлагается с помощью метода максимального правдоподобия: так же, как и в случае с двухклассовой логистической регрессией:
∑
i
=
1
N
log
max
i=1
∑
N
logP(y=y
i
∣x
i
,w)→
w
1
,…,w
K
max
Масштабируемость линейных моделей
Мы уже обсуждали, что SGD позволяет обучению хорошо масштабироваться по числу объектов, так как мы можем не загружать их целиком в оперативную память. А что делать, если признаков очень много, или мы не знаем заранее, сколько их будет? Такое может быть актуально, например, в следующих ситуациях:
Классификация текстов: мы можем представить текст в формате «мешка слов», то есть неупорядоченного набора слов, встретившихся в данном тексте, и обучить на нём, например, определение тональности отзыва в интернете. Наличие каждого слова из языка в тексте у нас будет кодироваться отдельной фичой. Тогда размерность каждого элемента обучающей выборки будет порядка нескольких сотен тысяч.
В задаче предсказания кликов по рекламе можно получить выборку любой размерности, например, так: в качестве фичи закодируем индикатор того, что пользователь X побывал на веб-странице Y. Суммарная размерность тогда будет порядка
⋅10
7
=10
16
. Кроме того, всё время появляются новые пользователи и веб-страницы, так что на этапе применения нас ждут сюрпризы.
Есть несколько хаков, которые позволяют бороться с такими проблемами:
Несмотря на то, что полная размерность объекта в выборке огромна, количество ненулевых элементов в нём невелико. Значит, можно использовать разреженное кодирование, то есть вместо плотного вектора хранить словарь, в котором будут перечислены индексы и значения ненулевых элементов вектора.
Даже хранить все веса не обязательно! Можно хранить их в хэш-таблице и вычислять индекс по формуле hash(feature) % tablesize. Хэш может вычисляться прямо от слова или id пользователя. Таким образом, несколько фичей будут иметь общий вес, который тем не менее обучится оптимальным образом. Такой подход называется hashing trick. Ясно, что сжатие вектора весов приводит к потерям в качестве, но, как правило, ценой совсем небольших потерь можно сжать этот вектор на много порядков.
Примером открытой библиотеки, в которой реализованы эти возможности, является vowpal wabbit.
Parameter server
Если при решении задачи ставки столь высоки, что мы не можем разменивать качество на сжатие вектора весов, а признаков всё-таки очень много, то задачу можно решать распределённо, храня все признаки в шардированной хеш-таблице
1
Кружки здесь означают отдельные сервера. Жёлтые загружают данные, а серые хранят части модели. Для обучения жёлтый кружок запрашивает у серого нужные ему для предсказания веса, считает градиент и отправляет его обратно, где тот потом применяется. Схема обладает бесконечной масштабируемостью, но задач, где это оправдано, не очень много.
Подытожим
На линейную модель можно смотреть как на однослойную нейросеть, поэтому многие методы, которые были изначально разработаны для них, сейчас переиспользуются в задачах глубокого обучения, а базовые подходы к регрессии, классификации и оптимизации вообще выглядят абсолютно так же. Так что несмотря на то, что в целом линейные модели на сегодня применяются редко, то, из чего они состоят и как строятся, знать очень и очень полезно.
Надеемся также, что главным итогом прочтения этого параграфа для вас будет осознание того, что решение любой ML-задачи состоит из выбора функции потерь, параметризованного класса моделей и способа оптимизации. В следующих параграфах мы познакомимся с другими моделями и оптимизаторами, но эти базовые принципы не изменятся.
Теперь предлагаем вам потренировать изученный материал на практике. Скачайте ноутбук с лабораторной работой. В нём вы найдете описания заданий и дополнительные материалы. Задания из лабораторной прикреплены к этому параграфу в виде задач в системе Яндекс Контест. Чтобы проверить себя, отправляйте решения по соответствующим задачам в систему. Успехов в практике!
Знак вопроса
Пройдите квиз по параграфу
Чтобы закрепить пройденный материал
Выполните задачи урока
0 / 7 выполнено
Сообщить об ошибке
Предыдущий параграф
1.3. Машинное обучение
Что такое машинное обучение и каким оно бывает. Основные понятия машинного обучения: признаки, таргеты, метрики, переобучение
Следующий параграф
2.2. Метрические методы
Алгоритмы KNN. Быстрый поиск ближайших соседей
