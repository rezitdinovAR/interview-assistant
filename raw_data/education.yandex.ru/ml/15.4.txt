---
title: Методы оптимизации в Deep Learning
url: https://education.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning
course: ml
chapter: 15. Онлайн-обучение и стохастическая оптимизация
chapter_id: 15.4
---
В выпуклой оптимизации такая точка обязательно будет точкой глобального минимума. В невыпуклой оптимизации все сильно сложнее:
Бывает много локальных минимумов
Бывают седловые точки
Локальный минимум — это критическая точка
w
∗
w
∗
, в которой Гессиан
H(w
∗
)=∇
2
f
t
(w
∗
) положительно определён. Отметим, что часто в методах глобальной оптимизации рассматривается так называемая «локальная выпуклость», для которой требуется, чтобы функция
(w) была выпуклой внутри некоторого шара радиуса
ϵ
ϵ с центром в точке
w
∗
w
∗
. Критические точки, в которых гессиан не является знакоопределённым, называются седловыми.
Пример: функция
f(x
1
,x
2
)=x
1
2
−x
2
2
имеет седловую точку
{
0
,
0
}
{0,0}. Гессиан в точке 0
H(0,0)=(
2
0
0
−2
)
Обратите внимание: во многих современных статьях про сходимость методов оптимизации первого порядка на невыпуклых функциях (пример) в качестве критерия сходимости рассматривают сходимость по норме градиента:
∣∣∇f(w)∣∣
2
2
<ϵ при некотором заранее фиксированном
ϵ
ϵ.
В выпуклой оптимизации этот критерий сходимости эквивалентен двум другим:
сходимости по расстоянию до оптимума в пространстве параметров:
∣∣w−w
∗
∣∣
2
2
<ϵ;
сходимости по расстоянию до оптимума по значениям функции
f(w)−f(w
∗
)<ϵ.
В невыпуклой оптимизации всё не так просто и поиск глобального минимума является в общем случае NP-трудной задачей. Критерий
∣∣∇f(w)∣∣
2
2
<ϵ даёт возможность исследовать сходимость к любой критической точке, но если речь об обучении нейронных сетях, то остается лишь надеяться, что эта критическая точка будет хорошим локальным минимумом.
Скользящее среднее в знаменателе AdaGrad. Методы RMSprop и Adam
Мотивация
В далекие 2012-2014е в мире было не так много опыта по построению хороших нейросетевых архитектур. «Канонические» методы оптимизации нейросетей RMSprop и Adam появлялись во времена, когда ещё не придумали основополагающих вещей вроде:
Residual connection и Dense connection (статьи опубликованы в 2015/2016 соответственно, во всех экспериментах используется SGD, в статье и в ссылках не упоминаются методы Adam/RMSprop), плохо решались проблемы взрывов/затуханий градиентов и т.д.
Batch Normalization и Layer Normalization (2015/2016 соответственно)
Также люди не умели правильно инициализировать нейросети гигантской глубины. статьи вроде 1000+ layer fully connected и 10000+ layer CNN позже. Кстати, этот цикл статей хочется особо отметить за интересную технику анализа распространения сигнала по нейронной сети.
В общем, в те времена царило архитектурное средневековье со всеми родовыми проблемами нейронных сетей:
Взрывы градиентов;
Затухания градиентов;
Взрывы-затухания сигнала на прямом проходе;
Плохие начальные инициализации, нестабильный старт обучения.
При попытках применять метод AdaGrad особо остро стояли проблемы 1 и 4. AdaGrad аккумулирует всю прошедшую историю
1:t
2
1
без затухания. Если в какой-то момент возникает одна из указанных проблем, знаменатель резко возрастает и больше не выправляется.
Чтобы побороть проблемы 1-4, решили поработать над оптимизатором и сделать так, чтобы история в AdaGrad аккумулировалась с затуханием и метод оптимизации мог со временем забыть плохие точки. Самый популярный и простой в реализации метод — экспоненциальное скользящее среднее.
RMSProp
Самая первая и самая простая модификация метода AdaGrad — метод RMSprop — вместо суммы использует экспоненциальное скользящее среднее в знаменателе:
=βv
t−1
+(1−β)g
t+1
Методу RMSprop не было посвящено ни одной специализированной статьи, равно как и не было никаких доказательств его сходимости даже для выпуклых задач.
Adam
Авторы Adam в статье Adam: A Method For Stochastic Optimization вводят два новшества по сравнению с RMSprop. Во-первых, это Momentum. Во вторых — Bias correction term. Напомним, как работает этот метод.
=0,m
t−1
+(1−β
t−1
+(1−β
2
)g
t
2
Применяем bias correction
1−β
1−β
t+1
Сразу перепишем
в нерекурсивной форме с зависимостью только от
1−β
2
t
1
(1−β
2
)
s=1
∑
t
β
2
t−s
1−β
1
t
1
(1−β
1
)
s=1
∑
t
β
1
t−s
g
s
Мотивация для bias correction
Авторы статьи пишут, что для правильной работы метода
должны быть несмещенными оценками
E
[
g
]
E[g] и
E
[
g
2
]
E[g
2
] соответственно. Допустим, все
g
t
g
t
— независимые одинаково распредёленные случайные величины. Это довольно сильное предположение, но иначе не получатся красивые формулы. Рассмотрим на примере
E[v
t
]=E[(1−β
2
)
s=1
∑
t
β
2
t−s
g
s
2
]=(1−β
2
)
s=1
∑
t
β
2
t−s
E[g
=((1−β
2
)
s=1
∑
t
β
2
t−s
)E[g
2
]=(1−β
2
t
)E[g
2
]
Отсюда очевидно, что исходные
смещены на множитель
(1−β
2
t
), поэтому авторы Adam делят на него
. Так как
lim
t→∞
lim
(1−β
2
t
)=1 при
0≤β
2
<1, эффект смещения сильнее всего заметен в начале итерационного процесса. Например, при классическом
β
2
=
0.999
β
2
=0.999 мы получаем смещение в 0.001 раз.
В начале обучения bias correction призван уменьшить слишком большие шаги оптимизатора.
Доказательство сходимости метода
В оригинальной статье приводится теорема с доказательством сублинейного Regret. Доказательство содержало ошибку, в новой работе 2018 года было доказано, что для любого набора гиперпараметров Adam существует выпуклая задача, на которой он не сходится. Проблемы со сходимостью, впрочем, не являются специфичными для выпуклых задач: в нейронных сетях Adam тоже может вести себя странно, и об этом мы поговорим ниже в разделе «Как сломать адаптивные методы».
Разбирать доказательство исходной статьи мы не будем, зато обратим внимание на пару неприятных фактов о различиях между «продаваемой» частью статьи и бекендом с экспериментами и доказательствами теорем.
Почему Adam стали считать лучшим методом стохастической оптимизации?
После успешного введения метода Adam в эксплуатацию в нейросети его окрестили «method of choice» в задачах стохастической оптимизации. Это было на 100% обусловлено его успехом в обучении нейронных сетей с нестабильными архитектурами.
Структура статьи выглядит следующим образом:
Выделенный в большую красивую видную рамочку алгоритм с дефолтными настройками вроде
α
=
0.001
α=0.001;
Формулировка теоремы в разделе про доказательства;
Эксперименты на нейросетях и выпуклых задачах.
В пункте 1 описан алгоритм, который все нынче знают, как Adam. Мало кто знает, что в доказательствах сходимости и в экспериментах на выпуклых задачах использовался немного другой алгоритм: вместо константного
α
α авторы статьи взяли
. Сравним эти learning rate с AdaGrad:
Метод
Формулы
AdaGrad
s=1
Adam
(1−β)
s=1
∑
t
β
t−s
g
s
2
1−β
t
Авторы в экспериментах на логистической регрессии убили основное свойство Adam — неубывающие learning rate. Вспомним, как в разделе про вывод AdaGrad мы анализировали порядок убывания learning rate — он был
=O(
t
1
). Отсюда следует, что у такого Adam learning rate убывают так же, как в AdaGrad. Словом, будьте внимательны при чтении статей: смотрите не только в описание алгоритмов, но и в их реализацию.
Настоящий Adam, который в pytorch и tensorflow реализован без множителя
1
t
t
1
, в выпуклой задаче разреженной логистической регрессии обычно работает намного хуже AdaGrad. Это справедливо как для чисто линейных моделей, так и для комбинированных Wide & Deep архитектур, из-за чего в одной и той же нейросети приходится использовать разные методы оптимизации для разных параметров.
Промежуточный итог по Adam/RMSProp
Тут нужно запомнить три идеи:
Momentum
Скользящее среднее в learning rate
Bias correction
На практике, часто почему-то рассматривают методы RMSprop и Adam как нечто отлитое в граните и не пытаются брать от них лучшее. Например, методу RMSprop обычно идет на пользу добавление bias correction от adam. Так что полезно помнить идеи, стоящие за методами оптимизации, и уметь их комбинировать.
Как сломать адаптивные методы со скользящим средним
Как и когда ломаются адаптивные методы
Все диагональные адаптивные методы так или иначе используют покоординатный learning rate
t,i
=
v
t,i
α
t
. Методы отличаются лишь формулировкой
v
t
,
i
v
t,i
Метод
Рекуррентные формулы
v
t
,
i
v
t,i
Развернутые формулы
v
t
,
i
v
t,i
α
t
α
t
AdaGrad
t−1,i
+g
t,i
t,i
=
s=1
∑
t
g
s,i
2
α
α
RMSprop
t−1,i
+(1−β)g
t,i
(1−β)
s=1
∑
t
β
t−s
g
s
2
α
α
Adam
t−1,i
+(1−β)g
t,i
(1−β)
s=1
∑
t
β
t−s
1−β
t
Все эти методы имеют единый вид формул FTRL, аналогичный формулам FTRL-AdaGrad:
min
t+1
=arg
w
min
g
1:t
T
w+
s=1
∑
t
∣∣w−w
s,i
=
v
s,i
s,i
=
α
s
v
s,i
−
α
s−1
v
s−1,i
Вспомним теоретические ограничения на
(w):
(w) — выпуклый;
(w)≥0.
Адаптивные методы с регуляризаторами
(w)=∣∣w∣∣
σ
t
2
будут удовлетворять этим условиям, если все
s,i
≥0. В этом месте и локаются методы со скользящим средним: никто не обещал, что последовательность
v
t
v
t
будет монотонно неубывать. Если же
s,i
<
α
s−1
v
s−1,i
,(∗)
то метод может ломаться
Обратите внимание. Momentum в методе Adam никак не повлияет на справедливость наших рассуждений, поскольку в формулах для адаптивных learning rate он не используется. Адаптивные методы с такими learning rate сломаются и с momentum, и без него.
Обратите внимание. Bias correction в методе Adam уменьшает learning rate в начале обучения, заставляя метод делать меньшие шаги.
Все рекуррентные формулы из таблицы можно переписать в виде
t−1
+C
2
g
t
2
Тогда неравенство
(
∗
)
(∗) можно записать в виде
t−1
t−1
v
t−1
t−1
(
α
t−1
Здесь мы можем подвести общую черту и сказать, что методы Adam и RMSprop дают
s,i
<0, когда
становится меньше предыдущей накопленной истории с точностью до некоторой константы.
А когда такое бывает? Уменьшение
, как правило, означает приближение к критическим точкам. Добавление квадратичных регуляризаторов с отрицательным коэффициентом приводит к тому, что метод оптимизации штрафует за близость к критическим точкам, заставляя убегать от них. Это приводит к тому, что метод не может нормально сойтись к локальным минимумам (в выпуклых задачах — просто к минимумам, что намного более критично).
Отметим, что по разным координатам
σ
s
,
i
σ
s,i
могут вести себя по-разному. Таким образом, можно получить ситуацию, когда мы поощряем близость по одним координатам и штрафуем за близость по другим.
Вывод условий поломок для конкретных методов
AdaGrad
AdaGrad невозможно сломать таким способом: для него гарантируется, что
t−1
.
RMSprop
t,i
=βv
t−1,i
+(1−β)g
t,i
2
Подставим в условие
(
∗
)
(∗), сразу сократив константный
=α:
t−1,i
+(1−β)g
t,i
2
<v
t−1,i
t,i
2
<v
t−1,i
Adam
Чисто технически, при выведении формул можно подумать, что Adam страдает от указанных эффектов гораздо сильнее RMSprop, но на самом деле это не так.
Переобозначим
β
2
β
2
из статьи про Adam как просто
β
β для общности обозначений.
Распишем неравенство
(
∗
)
(∗) для метода Adam:
1−β
t
βv
t−1
+(1−β)g
t
2
<
1−β
t−1
v
t−1
1−β
t
1−β
g
t
2
<v
t−1
(
1−β
t−1
1
−
1−β
1−β
t
1−β
g
t
2
<v
t−1
(1−β
t−1
)(1−β
t
)
1−β
t
−β+β
1−β
t−1
1
v
t−1
В отличие от RMSprop, у нас появился дополнительный множитель
1−β
t−1
1
>1. С одной стороны, можно подумать, что метод строго хуже. Однако, этот множитель сильно больше нуля только во время первых шагов оптимизации, тогда как рассматриваемая нами проблема играет роль только на поздних стадиях оптимизации при приближении к критическим точкам. А к тому моменту, этот множитель будет практически равен единице и мы получим формулы выше от RMSprop.
Поэтому, на самом деле, методы в одинаковой степени страдают от этих эффектов, но bias correction добавляет стабильности в начале.
Интерпретации
Избегание локальных минимумов или седловых точек
Если представить, что нейросеть — очень плохая и жутко невыпуклая задача, то можно рассматривать подобное поведение как «защиту» от промежуточных плохих критических точек, позволяющую нам «убегать» от них.
Данная интерпретация, к сожалению, имеет множество недостатков:
Никто не обещал, что новая критическая точка будет лучше старой и что мы, прыгая таким образом, будем улучшать качество модели.
Не каждый локальный минимум плохой. Если текущая критическая точка — хороший локальный минимум с хорошей обобщающей способностью, то мы просто нормально не сойдемся к нему и не достигнем хорошего качества модели.
Общественность уже идентифицировала такое поведение как проблему и решила ее в более поздних популярных оптимизаторах (см.раздел про AMSgrad).
Большинство современных рекомендаций по обучению больших неонлайновых моделей вроде GPT или картиночных моделей содержат в себе learning rate scheduler'ы как обязательный для успеха ингредиент. Эти рекомендации нивелируют проблему отрицательных регуляризаторов.
Все learning rate scheduler'ы заставляют learning rate убывать, что позволяет достигать лучших результатов, чем с помощью обычных Adam и RMSprop.
В параграфе про FTL мы узнали, что градиентный метод без регуляризации отвратительно работает даже на выпуклых задачах, а если мы начнём вводить отрицательную регуляризацию, да еще и на сложных невыпуклых задачах, то все может стать еще хуже.
В целом, мировой опыт говорит, что полагаться на подобные интерпретации при тюнинге модели не стоит.
Нестабильность в выпуклых задачах
Итак, методы RMSprop и Adam плохо работают для выпуклых задач, особенно для разреженных задач, и могут приводить к субоптимальным решениям на train. Тем не менее, есть искушение заявить, что «это такая регуляризация в классическом смысле: не слишком хорошо сходимся к оптимальной точке, не слишком сильно переобучаемся под датасет и можем лучше работать на тесте». Это искушение особенно опасно потому, что подобные эффекты действительно могут иметь место, особенно в классической (не онлайновой) постановке задачи. Любая регуляризация направлена на то, чтобы сдвинуть оптимум решения исходной некорректно поставленной задачи в надежде, что точка оптимума измененной задачи будет обладать лучшей обобщающей способностью на тесте. В частности, такой эффект может иметь ранняя остановка методов оптимизации до их сходимости к точке оптимума.
Однако здесь есть одно очень важное «но». Если введение регуляризации в некорректно поставленную задачу — это полностью осмысленный и контролируемый гиперпараметрами процесс, то хаотично разваливающийся вокруг точки оптимума метод оптимизации — нет. Подумайте: вдруг ваша задача фактически не является некорректно поставленной? Вдруг у вас огромный и очень репрезентативный датасет, благодаря чему оптимум на train всегда отлично работает в проде? В этом случае кривой метод оптимизации способен подпортить качество вашей модели.
Нестабильность в разреженных задачах
В задачах с разреженными параметрами ситуацию
t,i
2
<v
t−1,i
получить еще легче. Допустим, у нас есть некоторый параметр
w
i
w
i
, который встречается в 0.1% объектов выборки. В такой ситуации между появлениями этого объекта в выборке и очередным расчетом градиентов для него проходит значительное время. За это значительное время модель дообучалась, и за счет других, менее разреженных параметров могла научиться лучше прогнозировать очередной объект с этим параметром
w
i
w
i
. Тогда
∣∣g
t,i
∣∣
2
уменьшается и, следовательно, больше шансов попасть в плохую ситуацию.
Ниже мы рассмотрим метод AMSgrad и наперёд скажем, что для оптимизации разреженных параметров Adam/RMSprop добавление AMSgrad очень часто дает прибавку в качестве.
Зависимость нестабильности в регуляризаторе от learning rate
α
α
На первый взгляд, парадоксальным кажется следующий факт: чем меньше learning rate, тем в бОльшую сторону может отклониться отрицательный регуляризатор:
t−1
Однако в «жадных» формулах все с точностью до наоборот:
t+1
Из жадных формул очевидно, что уменьшение
α
α ведет к уменьшению шага и, как следствие, увеличению стабильности алгоритма.
Чтобы разрешить парадокс, надо вспомнить, что в FTRL решающее значение имеет не один отдельный регуляризатор, а сумма
σ
0
:
t
σ
0:t
. В начале процесса оптимизации
=0, первый регуляризатор точно не сломается. Чем меньше learning rate, тем меньшие шаги мы делаем от начальной точки и, следовательно, тем меньше должна отличаться норма градиентов.
Если от шага к шагу норма градиента меняется не слишком сильно, то мы накопим огромную кумулятивную регуляризацию
σ
0
:
t
σ
0:t
к моменту, когда регуляризатор решит отклониться в отрицательную сторону. При бОльшем learning rate мы шагаем быстрее, и точки, когда ломается регуляризатор, достигаем тоже быстрее, накопив гораздо меньшую сумму
σ
0
:
t
σ
0:t
. Если теперь для очередной точки мы получили отрицательный регуляризатор, то насколько сильно он может всё поломать?
Окей, допустим, мы шагнули к критической точке. А насколько сильно может расколбасить одна плохая точка в регуляризаторе? Так, чтобы он перекрыл всю предыдущую сумму
σ
0
:
t
σ
0:t
? Если градиенты ограничены по норме, то катастрофы, очевидно, не будет. Ограниченность градиентов по норме мы, с одной стороны, гарантировать не можем, с другой — проблемам взрыва/затухания градиентов в архитектурах уделяется столько внимания, что на практике это условие зачастую выполняется.
Чиним RMSprop и Adam
Мотивация
Время шло, люди учились строить хорошо обучаемые архитектуры. Стали даже появляться революционные идеи вроде ReZero (не путать с аниме) с полным отказом от batchnorm/layernorm нормализаций в глубоких сетях и с улучшением качества работы и скорости сходимости. Ситуация со стабильностью обучения нейросетей кардинально изменилась.
Несмотря на улучшение стабильности обучения, люди стали замечать, что при длительном процессе оптимизации Adam начинает сбоить. Авторы метода AMSgrad в статье On the Convergence of Adam and Beyond были одними из первых, кто провел почти аналогичный нашему анализ и добавили в Adam костыль, который обеспечивает выполнение условия
t−1
и исключает отрицательные регуляризаторы.
Обратите внимание: в разделее про Learning Rate Scheduling vs AdaGrad мы поговорим о «цикличности истории» развития методов оптимизации в deep learning.
AMSgrad
Авторы статьи On the Convergence of Adam and Beyond анализируют последовательность
t+1
=(
α
t+1
v
t+1
и говорят, что отрицательные значения в ней вызывают проблемы с процессом оптимизации. Их анализ в целом аналогичен приведённому выше, поэтому мы не будем его здесь дублировать.
Авторы статьи не стали предлагать новых схем learning rate и просто модифицировали старую: выполнение
>=v
t−1
обеспечивается «в лоб» при помощи
v
^
t
=
max
=max{v
t
,
v
^
t−1
},
v
^
0
=0.
Итоговое правило апдейта без momentum и без bias correction (оригинальный Algorithm 2 из статьи bias correction не использует):
=βv
t−1
+(1−β)g
max
=max{v
t
,
v
^
t−1
t+1
Если нужен метод с momentum, то можно просто заменить
g
t
g
t
в последней формуле на
=γm
t−1
+(1−γ)g
t+1
Реализация без дополнительной памяти
Оригинальные формулы из статьи
v
^
t
=
max
=max{v
t
,
v
^
t−1
} предполагают, что для расчета
мы держим два параметра:
v
t
−
1
v
t−1
t−1
. RMSprop и Adam хранят только один параметр
v
t
−
1
v
t−1
. Таким образом, включение метода требует дополнительных расходов памяти (х1.5 относительно RMSprop и x1.33 относительно Adam). Выше при разборе методов RMSprop/Adam мы сказали, что на практике AMSgrad помогает разреженным параметрам. Для разреженных моделей потребление памяти — краеугольный камень, поэтому простое включение дефолтной реализации amsgrad из статьи может быть болезненным и, к сожалению, не оправданным.
На практике же эвристика вида
v
t
=
max
=max{v
t
,v
t−1
} для разреженных параметров обычно работает так же хорошо и не требует дополнительной памяти. Никаких теоретических гарантий для нее нет, но на практике она работает.
Добавление bias correction
Оригинальная статья (и следующие букве оригинала стандартные реализации алгоритма, например, в PyTorch) предполагает убирание bias correction. Эксперименты на разреженных данных показывают, что убирание bias correction вредит сходимости, это полезная вещь.
С практической точки зрения, есть два способа реализовать bias correction в AMSgrad:
Post-correction:
max
1−β
t
1
max{v
t
,
v
^
t−1
},
Pre-correction:
v
^
t
=
max
=max{
1−β
t
1
v
t
,
1−β
t−1
1
v
^
t−1
}.
С точки зрения корректности метода AMSgrad, правильный вариант — pre-correction, так как он не ломает максимум. А вот эксперименты показывают, что добавление pre-correction ничего не даёт, а вот post-correction действительно помогает в том смысле, что AMSgrad + post-bias correction лучше, чем просто RMSProp/Adam с bias correction.
Соединяем эвристику + bias correction
Итоговые формулы можно использовать такие:
max
1−β
t
1
max{v
t
,
1−β
t−1
1
v
t−1
}
Learning Rate Scheduling
Другим способом улучшения сходимости методов RMSprop/Adam/SGD является learning rate scheduling (расписание learning rate, шедулер). Learning rate scheduler — это мета-алгоритм: они берёт любой стандартный метод оптимизации с константным параметром learning rate
α
α и предписывает схему изменения
α
t
α
t
на каждом шаге
t
t, или на каждой эпохе, или на любом другом заданном периоде.
Поскольку мы работаем с одним параметром
α
α, мы можем с ним делать всего две вещи: увеличивать или уменьшать. Эти два варианта имеют свои названия:
Learning rate decay — уменьшение learning rate с течением времени с целью нивелировать осцилляцию RMSprop/Adam около критических точек.
(Warm)Restart — обычно резкое увеличение learning rate. Warm — потому что мы уже сошлись в какую-то хорошую точку и сбрасываем только состояние оптимизатора в ней, но не переинициализируем сами параметры. WarmRestart может заключаться не только в увеличении
α
α, но и, например, в дополнительном сбросе состояния оптимизатора (обнуление momentum или
v
t
v
t
), хотя автор статьи такой подход встречали достаточно редко
Существует огромное количество вариантов расписания, каждый со своим графиком изменения
α
t
α
t
и со своим любовно подобранным множеством задач, на которых данный метод показывает себя лучше других. Приводить здесь их список особого смысла нет, лучше просто откройте документацию любого фреймворка и наслаждайтесь разнообразием вариантов.
Мы же обсудим влияние learning rate decay на осцилляцию вокруг критических точек и дадим практические рекомендации по подбору расписаний.
Влияние learning rate decay на сходимость
Для выпуклых задач в разделе про схемы убывания learning rate для FTRL-методов (константный регуляризатор,
sqrtt
1
и AdaGrad) мы буквально на оценках на regret видели, что это важный аспект для асимптотики сходимости.
В выпуклом случае, при приближении к минимуму мы должны оптимизировать решение с куда большей точностью. Норма градиентов при приближении к минимуму тоже уменьшаются, поэтому даже с константным
O
(
1
)
O(1) learning rate шаги будут становиться меньше, но — как показывают и теоретические оценки на regret, и многочисленные их валидации в статьях — этого недостаточно. Уменьшение learning rate с правильной асимптотикой уменьшения дает куда более хорошие результаты. Для глубинного обучения и оптимизации к каким-то локальным минимумам эта логика тоже применима.
Возвращаясь к методам Adam/RMSprop — напомним, что у них асимптотика learning rate
O
(
1
)
O(1). Им в любом случае пойдет на пользу уменьшение learning rate, даже если не брать во внимание их проблемы вокруг критических точек и взять метод AMSgrad, который от этих проблем не страдает.
Отсюда же очевидно, что проблемы adam/rmsprop начинают стрелять гораздо меньше. Learning rate уменьшается => от критической точки мы в плохих ситуациях шагаем на гораздо меньшее расстояние => область, вокруг которой мы будем «прыгать», сужается => мы худо-бедно, но сходимся.
Практические рекомендации
Как мы уже отмечали выше, шедулеров существует поистине фантастическое количество, гораздо больше, чем базовых оптимизаторов, к которым они применяются. Без структуризации подхода к ним работать становится сложно.
Мы хотели бы дать вам следующие рекомендации:
Выучите свою модель без learning rate scheduling со стандартными методами оптимизации и посмотрите, как ведёт себя loss для различных learning rate. Обязательно переберите learning rate на этом шаге.
Начинать внедрение расписаний рекомендуем с шедулеров, которые только уменьшают learning rate. Классические варианты — ReduceOnPlateou или linear decay. Правильный подбор learning rate и темпа его уменьшения очень важны в любой задаче стохастической оптимизации.
Только после того, как вы хорошенько потюните learning rate decay, можно смотреть в сторону WarmRestart. Иногда рестарты могут помочь. Автор статьи занимается в основном рекомендательными моделями и там эту технику практически никто не применяет.
Learning rate scheduling vs AdaGrad
У методов SGD/RMSprop/Adam последовательность
∼O(1) не является асимптотически убывающей, и для того, чтобы это скомпенсировать, используется расписание learning rate. А вот у AdaGrad с
η
t
η
t
и так всё в порядке.
Давайте восстановим хронологию событий:
Метод AdaGrad пытаются применять к нейросетям в 2012+ годах, но тогда архитектуры были нестабильны, градиенты взрывались и навсегда портили знаменатель AdaGrad, сильно уменьшая learning rate.
Появляются методы RMSprop/Adam (2013/2014) со скользящим средним в знаменателе, которые могут оправиться от взрыва градиента.
Развитие архитектур нейронных сетей не стоит на месте, появляются разные виды residual connection (2015), LayerNorm/BatchNorm (2015-2016), крутые методы начальной инициализации — огромное количество способов улучшения стабильности обучения.
С развитием архитектур люди замечают, что RMSProp/Adam умеют застревать на одном уровне значений функции потерь, и начинают применять техники для уменьшения learning rate.
В дальнейших работах метод AdaGrad часто рассматривается наравне с Adam/RSMprop и дает очень похожее, либо даже лучшее качество (см, например, статью про Shampoo). А дело в том, что архитектуры уже очень хорошо инициализируются и правильно проектируются так, чтобы не было взрывов/затуханий градиентов ни на какой стадии оптимизации.
Развитие методов оптимизации в deep learning сделало небольшой круг, и мы рекомендуем об этом помнить. Порой люди могут одновременно рассуждать о бесценной пользе learning rate decay (особенно с линейным убыванием как
1
t
t
1
) и корить AdaGrad за бесконечное аккумулирование квадратов градиентов (которые убывают как
1
t
t
1
). Так что если у вас вдруг хорошо заработал шедулер с
∼O(
t
1
) — возможно, обычный AdaGrad будет лучше?
SGD vs Adam
В последнее время в литературе часто появляются заявления, что решения, полученные адаптивными методами в нейросетях, обладают худшей обобщающей способностью. Сразу хотим отметить, что большинство этих статей исследуют эти эффекты только на задачах Computer Vision на одних и тех же датасетах MNIST/CIFAR/ImageNet. В реальной жизни куда большее разнообразие постановок задач и датасетов, что сразу заставляет сомневаться в воспроизводимости этих эффектов. Рекомендация тут одна, как и всегда — досконально сами все проверяйте.
AdamW, SGDW
Данные методы предложены авторами в статье Decoupled Weight Decay Regularization, которую мы подробно разобрали в разделее про продвинутую
L
2
L
2
регуляризацию. Методы AdamW и SGDW — это просто модификации методов Adam и SGD с momentum, которые используют линеаризованный decoupled
L
2
L
2
.
Авторы статьи изучали проблему, почему в их экспериментах SGD обобщает лучше Adam (но учится дольше и требует более аккуратной настройки). Они пришли к выводу, что дело не в магии SGD, а в том, что
L
2
L
2
-регуляризация у этих двух методов работает по-разному. Добавив decoupling, авторы сумели показать, что decoupled Adam обгоняет SGD.
Эти эффекты, повторимся, были уже рассмотрены ранее в разделее про продвинутую
L
2
L
2
регуляризацию. Единственное, что мы не обсудили тогда — это momentum. В постановке Proximal Gradient Descent градиент заменяется на momentum
t+1
∣∣w−w
=γm
t−1
+(1−γ)g
t+1
∣∣w−w
t+1
Покоординатные
η
t
η
t
могут рассчитываться любыми методами: AdaGrad, RMSprop или Adam, не принципиально.
На всякий случай напомним, что мы вывели потенциально более правильные формулы
t+1
∣∣w∣∣
∣∣w−w
t+1
=
1+λ
Метод SGDW получается из формул выше, если убрать покоординатность
η
t
η
t
К сожалению, здесь мы не почерпнули новых идей, так как выяснили, что это просто очередная инкарнация Proximal методов оптимизации.
RAdam
Этот метод заключается в том, чтобы стартовать с адаптивного метода Adam и в некоторый момент переключиться на SGD. «Некоторый момент» — это, интуитивно, момент стабилизации всех статистик в Adam, когда мы выжали все из ускоренного старта адаптивных методов и хотим получше сойтись к хорошему оптимуму в найденной им окрестности.
Отметим, что позднее переключение на SGD с неубывающими learning rate автоматически починит проблемы расходимости Adam ровно там, где они чаще всего и возникают: при хорошем приближении к локальным минимумам.
Мы не будем здесь подробно рассматривать их анализ, вы можете сами познакомиться с ним в статье On The Variance Of The Adaptive Learning Rate And Beyond
Online RMSprop
Особняком стоит метод, описанный в статье Variants of RMSProp and Adagrad with Logarithmic Regret Bounds. Авторы не придумывали очередной хотфикс, а аккуратно заново выводили формулы. Также важно, что данный метод является строгим обобщением метода AdaGrad.
В работе есть два нововведения:
Переформулировка метода RMSprop так, чтобы:
— Осталось экспоненциальное скользящее среднее;
— Не было проблемы с отрицательными регуляризаторами и взрывающимися learning rate;
— Метод AdaGrad являлся частным случаем нового метода;
— Чтобы все эмпирически хорошо работало в т.ч. на глубоких моделях
Формулировка новых алгоритмов оптимизации SC-AdaGrad и SC-RMSprop для сильно выпуклых функций с логарифмическими гарантиями на regret. SC в названии — Strongly Convex.
Пока рассмотрим только первый пункт. Авторы вводят следующий общий метод:
t−1
+(1−β
t+1
Нововведение здесь в том, что вместо фиксированного
β
β мы будем рассматривать последовательность
β
t
β
t
. Авторы доказывают сублинейный regret для любых последовательностей, удовлетворяющих
≤1−
0<γ≤1
AdaGrad как частный случай
Докажем, что метод Adagrad — это метод OnlineRMSprop с
γ
=
1
γ=1. Аналогично выводам momentum в FTRL, перепишем рекуррентное выражение для
v
t
+
1
v
t+1
s=1
∑
t
(1−β
s
)
k=s+1
Подставив
β=1−
t
1
, получим
s=1
∑
t
(1−β
s
)(
k=s+1
s=1
k=s+1
∏
t
t
t−1
s=1
k=s+1
∏
t
k
k−1
=
s=1
s=1
∑
t
g
s
2
Далее, подставляя это в формулу
, получаем
s=1
s=1
Анализ OnlineRMSprop с
γ
<
1
γ<1 в стиле FTRL. Пригодность для выпуклых задач
Докажем, что OnlineRMSprop не может сломать регуляризаторы в regret. Для этого преобразуем неравенство
t−1
v
t−1
<(t−1)v
t−1
t(β
t
v
t−1
+(1−β
t
)g
t
2
)<(t−1)v
t−1
t((1−
t
γ
)v
t−1
)<(t−1)v
t−1
t−1
(t−1−t(1−
t−1
(γ−1)
Из условия
0
<
γ
≤
1
0<γ≤1 получаем, что правая часть неравенства неположительна, а левая неотрицательно. Значит, последнее неравенство невозможно, то есть все
≥0. Таким образом, регуляризаторы не сломаются, сходимость будет иметь место и данный метод можно использовать в выпуклых задачах. Строгое доказательство сходимости и оценки на Regret можно прочитать в исходной статье.
Эффективный learning rate
Как и ранее в методе AdaGrad, допустим, что
∣∣g∣∣
2
<R. Тогда
j=1
∑
t
(1−β
j
)
k=j+1
j=1
∑
t
(1−β
j
)
k=j+1
∏
t
β
k
α
При
≤1−
t
γ
выполнено
lim
t→∞
lim
j=1
∑
t
(1−β
j
)
k=j+1
∏
t
β
k
=1
Докажем, что все элементы предела < 1. Из этого, в частности, будет следовать, что learning rate у OnlineRMSprop не меньше, чем learning rate в AdaGrad.
Если все все
=1, то итерационный процесс OnlineRMSprop превращается в
t−1
+(1−β
t
)
Предположим, что
≥1. Тогда:
t−1
+(1−β
t
)≥1
(1−
t
γ
)v
t−1
t−1
≥1
По индукции разворачиваем вплоть до
=0, получаем противоречие.
Полное доказательство предела оставляем читателям. Надо бы чем-нибудь снизу подпереть, что тоже к 1 сходится. Автор сдавал матан почти 10 лет назад и ему было очень неохота откапывать все эти прекрасные пределы, поэтому ответ был получен с помощью wolfram.
Вывод: learning rate у OnlineRMSprop убывает со скоростью
=O(
t
1
). Мы исправили ошибку предыдущего RMSprop, изменив только перевзвешивание, но не асимптотику в
η
t
η
t
. Такой RMSprop можно пробовать использовать в выпуклых задачах
Momentum
Попробуем расписать классический momentum с константным learning rate в стиле FTRL:
t+1
=βv
t
+(1−β)g
t+1
=w
t
−αv
t+1
Всё, что нам нужно сделать — это взять все рекурсивные зависимости от предыдущей итерации и «размотать» их, получив явное выражение.
Зависимость
w
t
+
1
w
t+1
от
w
t
w
t
переписать довольно просто, мы это уже делали для обычного градиентного спуска:
t+1
=−α
i=1
∑
t
v
i
Теперь надо размотать
=(1−β)
i=1
∑
t
β
t−i
g
i
Теперь будет чуть сложнее. Подставим это и попробуем расписать, как сумму
g
i
g
i
с определенными коэффициентами:
t+1
=−α
i=1
∑
t
v
i
=−α
i=1
∑
t
(1−β)
j=1
∑
i
β
i−j
g
j
Множитель
−α(1−β) сразу выносим за сумму и пока забываем.
i=1
∑
t
j=1
∑
i
β
i−j
g
j
=
i=1
∑
t
j=1
∑
t
I(j≤i)β
i−j
j=1
∑
t
i=1
∑
t
I(j≤i)β
i−j
g
j
=
j=1
∑
t
g
j
i=1
∑
t
I(j≤i)β
i−j
j=1
∑
t
g
j
i=j
∑
t
β
i−j
Отлично, а теперь нам нужно получить последовательность функций. В линеаризованной задаче это фактически эквивалентно получению зависимости
z
t
+
1
z
t+1
от
z
t
z
t
, где, напомним,
z
t
z
t
— это сумма градиентов.
t+1
−z
t
=
j=1
∑
t+1
g
j
i=j
∑
t+1
β
i−j
−
j=1
∑
t
g
j
i=j
∑
t
β
i−j
=g
t+1
+
j=1
∑
t
g
j
i=j
∑
t+1
β
i−j
−
j=1
∑
t
g
j
i=j
∑
t
β
i−j
=g
t+1
+
j=1
∑
t
β
t+1−j
g
j
=
j=1
∑
t+1
β
t+1−j
g
j
Теперь мы можем записать функцию, градиент которой равен
t+1
−z
t
и онлайн-оптимизация которой эквивалентна процедуре с моментумом:
(w)=
j=1
∑
t
β
t−j
f
j
(w)
Получаем, что для онлайн-обучения мы на самом деле каждую итерацию скармливаем экспоненциально взвешенную последовательность всех предыдущих функций исходной последовательности. В принципе, нечто такое мы и ожидали увидеть. Функции
(w)
^
, очевидно, выпуклы, так что для данной измененной последовательности функций будет сублинейный regret.
Nesterov Momentum
Рассмотрим классический SGD с momentum, для всех adaptive методов рассуждения аналогичны.
=γm
t−1
+(1−γ)g
t+1
=w
t
−αm
t
Градиент функции
g
t
g
t
посчитан в предыдущей точке
w
t
w
t
. Идея nesterov momentum в том, чтобы применить momentum на параметры
w
t
w
t
до вычисления градиента:
=∇f
=∇f
t
(w
t
−m
t−1
)
У метода много всяких «интуитивных объяснений», но изначально Nesterov Momentum был выведен сугубо аналитическими методами. Увы, попытки добавлять его в стохастическую оптимизацию «в лоб» обычно улучшением качества не заканчиваются. Анализ того, почему так нельзя и делать и как можно сделать правильно, проводится в работах Katyusha: The First Direct Acceleration of Stochastic Gradient Methods и Natasha-2 (мотивация их автора Zeyuan Allen-Zhu для выбора таких наименований доподлинно неизвестна). Katuysha правильным образом использует nesterov momentum для выпуклого случая, Natasha — для невыпуклого. Данные методы используют подход SVRG для улучшения сходимости и ускорение оптимизации происходит только при приближении к точке оптимума.
Adan
До недавнего времени громких историй успеха для nesterov momentum в глубоком обучении не было. Метод Natasha распространения не нашел. Наконец, авторы статьи Adan (2022) нашли способ правильной обработки Nesterov Momentum. Метод показал отличные результаты и обновил SOTA метрики на широком спектре задач.
Собираем все идеи воедино
Авторы данного обзора очень хотят, чтобы читатель ушел не с знанием набора наименований методов оптимизации, а с знанием набора концепций, которые тот или иной метод реализует, и при случае мог сам подстроить метод под свои нужды. Тюнинг методов оптимизации — один из главных способов улучшения качества модели на фиксированном датасете.
Adaptive learning rate — автоматическое подстраивание метода под геометрию задачи оптимизации. Крайне важный класс методов для выпуклых/невыпуклых задач. Must-have для разреженных моделей. Методы: AdaGrad/RMSprop/Adam.
Скользящее среднее в adaptive learning rate представлено в методах RMSprop/Adam. Не забывайте про их плохое поведение вокруг критических точек и проблемы со сходимостью на финальных этапах оптимизации.
BiasCorrection: стабилизация обучения на старте для адаптивных методов со скользящим средним. Большинство экспериментов показывают, что это крайне полезная штука и стоит всегда её использовать. В том числе стоит использовать RMSprop с bias correction, если вам не нужны momentum и Adam.
AMSgrad: способ починить сходимость RMSprop/Adam. Не забывайте, что стандартные реализации при использовании AMSgrad отключают bias correction, а это на самом деле может навредить, а также о том, что можно реализовать AMSgrad без дополнительной памяти, и всё будет хорошо работать.
Learning rate decay: убывание learning rate зачастую является очень важной деталью в стохастической оптимизации. Помните, что можно брать как AdaGrad, в котором это есть из коробки со скоростью
) (но архитектура нейросети должна быть хорошей), так и комбинацию RMSProp/Adam + learning rate scheduler.
WarmRestart: эвристика, резко увеличивающая learning rate после достижения некоторой точки в процессе оптимизации. Практически всегда идет бок о бок с learning rate decay. Где-то помогает
Проксимальные методы для функций потерь с регуляризаторами: ProximalGD/AdamW/SGDW/FTRL-Proximal. Must-have для
L
1
L
1
-регуляризаторов, без проксимальности они вообще не работают.
FTRL-Proximal: lazy vs greedy представление. Переписываем представление любого метода оптимизации в не-жадный вид. Позволяет по-новому взглянуть на любые регуляризаторы, особенно негладкие. Must-have для
L
1
L
1
-регуляризации.
L
1
L
1
-регуляризация в FTRL-Proximal: Incremental/Fixed/SquareIncremental. Все три имеют разные свойства и разную область применения. Fixed является наилучшим для отбора разреженных признаков/эмбеддингов.
L
1
/
2
L
1/2
-регуляризатор для отбора эмбеддингов или автоматического подбора размерности. Можно использовать как аналог FSTR. Крайне полезный подход для разреженных нейросетей в рекомендательных системах, для которых рекомендуется использовать адаптивную схему SquareIncremental.
Heavy-ball Momentum: используется для ускорения процесса оптимизации. В выпуклых задачах имеет доказанные оценки на улучшение скорости сходимости, в нейросетях используется как эвристика (зачастую опциональная).
Nesterov momentum: в выпуклом случае гораздо мощнее для batch gradient descent, чем обычный momentum, и это подверждается теоретическими гарантиями. В стохастических методах оптимизации и в онлайн обучении «в лоб» применять нельзя: для выпуклого случая подойдет Katyusha, для нейросетей — Adan.
Главное, что мы хотим подчеркнуть, — эти идеи друг другу не противоречат и их можно свободно комбинировать друг с другом. Например, можно собрать себе FTRL-Proximal метод с
L
1
L
1
-регуляризацией, любым momentum и RMSprop learning rate с AMSgrad. Или любую другую комбинацию. Всегда можно выбрать оптимальный набор под задачу.
Пример таблицы с общими формулами
Эти формулы используют все подходы выше в едином фреймворке, чтобы наглядно убедиться в том, что все можно друг с другом комбинировать.
Generic FTRL-Proximal
min
t+1
=arg
w
min
g
^
1:t
T
w+λ
1,t
∣∣w∣∣
1
+
2
1
∣∣w∣∣
λ
2,t
2
+
2
1
s=1
∑
t
∣∣w−w
1:t
−
s=1
t+1,i
={
0
−
1+λ
2,t
σ
1:t
σ
1:t
(z
t
−sign(z
t
)λ
1,t
)
∣z
t,i
∣≤λ
1,t
∣z
t,i
∣>λ
1,t
Generic Mirror (Proximal) Gradient Descent
min
t+1
=arg
w
min
g
^
t
T
w+λ
1,t
∣∣w∣∣
1
+
2
1
∣∣w∣∣
λ
2,t
2
+
2
1
∣∣w−w
t+1
={
0
−
1+λ
2,t
−sign(z
t
)λ
1,t
)
∣z
t
∣≤λ
1,t
∣z
t
∣>λ
1,t
Связь:
t−1
1
Идея
FTRL (lazy)
Gradient Descent (greedy)
Комментарии
Momentum
=γm
t−1
+(1−γ)g
То же самое
Не влияет на adaptive
v
t
v
t
Константный learning rate
=0,t>0
Убывающий непокоординатный learning rate
t−1
Обычно берут
=O(
t
1
)
Generic Adaptive learning rate
t−1
v
t−1
— векторы, везде ниже умножение
означает покоординатное умножение
Generic Adaptive learning rate с scheduler
S(α,t)
S(α
t
,t)
v
t
−
S(α
t−1
,t)
v
t−1
S(α
t
,t)
Например, в Adam:
1−β
t
→S(α,t)
1−β
t
Adaptive learning rate: AdaGrad
s=1
s=1
s=1
=O(
t
1
)
Adaptive learning rate: RMSprop
=βv
t−1
+(1−β)v
То же самое
=O(1), ломается у критических точек
Adaptive learning rate: Online RMSprop
t−1
+(1−β
=1−
t
γ
То же самое
=O(
t
1
)
Adaptive learning rate: Adam
=βv
t−1
+(1−β)v
1−β
t
То же самое
=O(1), ломается у критических точек
Adaptive learning rate: AMSgrad
=βv
t−1
+(1−β)v
То же самое
=O(1)
Adaptive learning rate: RAdam
Многобукв
Многобукв
=O(1)
Классическая
L
2
L
2
регуляризация
2,t
2,t
=λ
2
Decoupled
L
2
L
2
регуляризация
2,t
=
σ
0:t
2,t
=
η
t
λ
2
Инкрементальная
L
1
L
1
регуляризация
1,t
=tλ
1,t
=λ
1
Фиксированная
L
1
L
1
регуляризация
1,t
=λ
1
Отсутствует
Знак вопроса
Пройдите квиз по параграфу
Чтобы закрепить пройденный материал
Сообщить об ошибке
Предыдущий параграф
15.3. Регуляризация в онлайн-обучении
Следующий параграф
16.1. Матричное дифференцирование
Как дифференцировать матрицы и дифференцировать по матрицам: всё, что вам не рассказали про дифференцирование на матанализе
