---
title: Small Quiz (ungraded)
url: https://huggingface.co/learn/agents-course/unit2/smolagents/quiz2
course: agents-course
chapter: Unit 2.1 The smolagents framework
chapter_id: unit2/smolagents/quiz2
---
# Small Quiz (ungraded)

 
Itâ€™s time to test your understanding of the *Code Agents*, *Tool Calling Agents*, and *Tools* sections. This quiz is optional and not graded.
  

### Q1: What is the key difference between creating a tool with the @tool decorator versus creating a subclass of Tool in smolagents?

 
Which statement best describes the distinction between these two approaches for defining tools?
  Using the `@tool` decorator is mandatory for retrieval-based tools, while subclasses of `Tool` are only for text-generation tasks  The `@tool` decorator is recommended for simple function-based tools, while subclasses of `Tool` offer more flexibility for complex functionality or custom metadata  `@tool` can only be used in multi-agent systems, while creating a `Tool` subclass is for single-agent scenarios  Decorating a function with `@tool` replaces the need for a docstring, whereas subclasses must not include docstrings    

### Q2: How does a CodeAgent handle multi-step tasks using the ReAct (Reason + Act) approach?

 
Which statement correctly describes how the CodeAgent executes a series of steps to solve a task?
  It passes each step to a different agent in a multi-agent system, then combines results  It stores every action in JSON for easy parsing before executing them all at once  It cycles through writing internal thoughts, generating Python code, executing the code, and logging the results until it arrives at a final answer  It relies on a vision module to validate code output before continuing to the next step    

### Q3: Which of the following is a primary advantage of sharing a tool on the Hugging Face Hub?

 
Select the best reason why a developer might upload and share their custom tool.
  It automatically integrates the tool with a MultiStepAgent for retrieval-augmented generation  It allows others to discover, reuse, and integrate your tool in their smolagents without extra setup  It ensures that only CodeAgents can invoke the tool while ToolCallingAgents cannot  It converts your tool into a fully vision-capable function for image processing    

### Q4: ToolCallingAgent differs from CodeAgent in how it executes actions. Which statement is correct?

 
Choose the option that accurately describes how ToolCallingAgent works.
  ToolCallingAgent is only compatible with a multi-agent system, while CodeAgent can run alone  ToolCallingAgent delegates all reasoning to a separate retrieval agent, then returns a final answer  ToolCallingAgent outputs JSON instructions specifying tool calls and arguments, which get parsed and executed  ToolCallingAgent is only meant for single-step tasks and automatically stops after calling one tool    

### Q5: What is included in the smolagents default toolbox, and why might you use it?

 
Which statement best captures the purpose and contents of the default toolbox in smolagents?
  It provides a set of commonly-used tools such as DuckDuckGo search, PythonInterpreterTool, and a final answer tool for quick prototyping  It only supports vision-based tasks like image classification or OCR by default  It is intended solely for multi-agent systems and is incompatible with a single CodeAgent  It adds advanced retrieval-based functionality for large-scale question answering from a vector store    
Congratulations on completing this quiz! ðŸŽ‰ If any questions gave you trouble, revisit the *Code Agents*, *Tool Calling Agents*, or *Tools* sections to strengthen your understanding. If you aced it, youâ€™re well on your way to building robust smolagents applications!